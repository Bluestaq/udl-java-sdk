// File generated from our OpenAPI spec by Stainless.

package com.unifieddatalibrary.api.models.manifoldelset

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.unifieddatalibrary.api.core.Enum
import com.unifieddatalibrary.api.core.ExcludeMissing
import com.unifieddatalibrary.api.core.JsonField
import com.unifieddatalibrary.api.core.JsonMissing
import com.unifieddatalibrary.api.core.JsonValue
import com.unifieddatalibrary.api.core.Params
import com.unifieddatalibrary.api.core.checkRequired
import com.unifieddatalibrary.api.core.http.Headers
import com.unifieddatalibrary.api.core.http.QueryParams
import com.unifieddatalibrary.api.errors.UnifieddatalibraryInvalidDataException
import java.time.OffsetDateTime
import java.util.Collections
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/**
 * Service operation to take a single ManifoldElset as a POST body and ingest into the database. A
 * ManifoldElset represents theoretical Keplarian orbital elements belonging to an object of
 * interest's manifold describing a possible/theoretical orbit for an object of interest for tasking
 * purposes. A specific role is required to perform this service operation. Please contact the UDL
 * team for assistance.
 */
class ManifoldelsetCreateParams
private constructor(
    private val body: Body,
    private val additionalHeaders: Headers,
    private val additionalQueryParams: QueryParams,
) : Params {

    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun classificationMarking(): String = body.classificationMarking()

    /**
     * Indicator of whether the data is REAL, TEST, EXERCISE, or SIMULATED data:
     *
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and
     * analysis.
     *
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
     * requirements, and for validating technical, functional, and performance characteristics.
     *
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include
     * both real and simulated data.
     *
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun dataMode(): DataMode = body.dataMode()

    /**
     * Elset epoch time in ISO 8601 UTC format, with microsecond precision.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun epoch(): OffsetDateTime = body.epoch()

    /**
     * Identifier of the parent Manifold record.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun idManifold(): String = body.idManifold()

    /**
     * Source of the data.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun source(): String = body.source()

    /**
     * A placeholder satellite number and not a true NORAD catalog number.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun tmpSatNo(): Int = body.tmpSatNo()

    /**
     * Unique identifier of the record, auto-generated by the system.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun id(): Optional<String> = body.id()

    /**
     * The Orbit point furthest from the center of the earth in kilometers.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun apogee(): Optional<Double> = body.apogee()

    /**
     * The argument of perigee is the angle in degrees formed between the perigee and the ascending
     * node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun argOfPerigee(): Optional<Double> = body.argOfPerigee()

    /**
     * The drag term for SGP4 orbital model, used for calculating decay constants for altitude,
     * eccentricity etc, measured in inverse earth radii.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun bStar(): Optional<Double> = body.bStar()

    /**
     * Time the row was created in the database, auto-populated by the system.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun createdAt(): Optional<OffsetDateTime> = body.createdAt()

    /**
     * Application user who created the row in the database, auto-populated by the system.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun createdBy(): Optional<String> = body.createdBy()

    /**
     * The orbital eccentricity of an astronomical object is a parameter that determines the amount
     * by which its orbit around another body deviates from a perfect circle. A value of 0 is a
     * circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit,
     * and greater than 1 is a hyperbolic escape orbit.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun eccentricity(): Optional<Double> = body.eccentricity()

    /**
     * The angle between the equator and the orbit when looking from the center of the Earth. If the
     * orbit went exactly around the equator from left to right, then the inclination would be 0.
     * The inclination ranges from 0 to 180 degrees.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun inclination(): Optional<Double> = body.inclination()

    /**
     * Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on
     * create/edit operations.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun line1(): Optional<String> = body.line1()

    /**
     * Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on
     * create/edit operations.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun line2(): Optional<String> = body.line2()

    /**
     * Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees.
     * The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean
     * anomaly would be 0.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun meanAnomaly(): Optional<Double> = body.meanAnomaly()

    /**
     * The constant angular speed required for the body to complete one circular orbit in the same
     * amount of time as the actual elliptical orbit with variable speed. Measured in revolutions
     * per day.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun meanMotion(): Optional<Double> = body.meanMotion()

    /**
     * 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun meanMotionDDot(): Optional<Double> = body.meanMotionDDot()

    /**
     * 1st derivative of the mean motion with respect to time. Units are revolutions per day
     * squared.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun meanMotionDot(): Optional<Double> = body.meanMotionDot()

    /**
     * Originating system or organization which produced the data, if different from the source. The
     * origin may be different than the source if the source was a mediating system which forwarded
     * the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun origin(): Optional<String> = body.origin()

    /**
     * The originating source network on which this record was created, auto-populated by the
     * system.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun origNetwork(): Optional<String> = body.origNetwork()

    /**
     * The orbit point nearest to the center of the earth in kilometers.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun perigee(): Optional<Double> = body.perigee()

    /**
     * Period of the orbit equal to inverse of mean motion.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun period(): Optional<Double> = body.period()

    /**
     * Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards
     * (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending
     * node, which is where the orbit crosses the equator when traveling north.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun raan(): Optional<Double> = body.raan()

    /**
     * The current revolution number. The value is incremented when a satellite crosses the equator
     * on an ascending pass.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun revNo(): Optional<Int> = body.revNo()

    /**
     * The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the
     * semimajor axis is the distance between the centers of the bodies, not the distance of the
     * bodies from the center of mass.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun semiMajorAxis(): Optional<Double> = body.semiMajorAxis()

    /**
     * Returns the raw JSON value of [classificationMarking].
     *
     * Unlike [classificationMarking], this method doesn't throw if the JSON field has an unexpected
     * type.
     */
    fun _classificationMarking(): JsonField<String> = body._classificationMarking()

    /**
     * Returns the raw JSON value of [dataMode].
     *
     * Unlike [dataMode], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _dataMode(): JsonField<DataMode> = body._dataMode()

    /**
     * Returns the raw JSON value of [epoch].
     *
     * Unlike [epoch], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _epoch(): JsonField<OffsetDateTime> = body._epoch()

    /**
     * Returns the raw JSON value of [idManifold].
     *
     * Unlike [idManifold], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _idManifold(): JsonField<String> = body._idManifold()

    /**
     * Returns the raw JSON value of [source].
     *
     * Unlike [source], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _source(): JsonField<String> = body._source()

    /**
     * Returns the raw JSON value of [tmpSatNo].
     *
     * Unlike [tmpSatNo], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _tmpSatNo(): JsonField<Int> = body._tmpSatNo()

    /**
     * Returns the raw JSON value of [id].
     *
     * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _id(): JsonField<String> = body._id()

    /**
     * Returns the raw JSON value of [apogee].
     *
     * Unlike [apogee], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _apogee(): JsonField<Double> = body._apogee()

    /**
     * Returns the raw JSON value of [argOfPerigee].
     *
     * Unlike [argOfPerigee], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _argOfPerigee(): JsonField<Double> = body._argOfPerigee()

    /**
     * Returns the raw JSON value of [bStar].
     *
     * Unlike [bStar], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _bStar(): JsonField<Double> = body._bStar()

    /**
     * Returns the raw JSON value of [createdAt].
     *
     * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _createdAt(): JsonField<OffsetDateTime> = body._createdAt()

    /**
     * Returns the raw JSON value of [createdBy].
     *
     * Unlike [createdBy], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _createdBy(): JsonField<String> = body._createdBy()

    /**
     * Returns the raw JSON value of [eccentricity].
     *
     * Unlike [eccentricity], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _eccentricity(): JsonField<Double> = body._eccentricity()

    /**
     * Returns the raw JSON value of [inclination].
     *
     * Unlike [inclination], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _inclination(): JsonField<Double> = body._inclination()

    /**
     * Returns the raw JSON value of [line1].
     *
     * Unlike [line1], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _line1(): JsonField<String> = body._line1()

    /**
     * Returns the raw JSON value of [line2].
     *
     * Unlike [line2], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _line2(): JsonField<String> = body._line2()

    /**
     * Returns the raw JSON value of [meanAnomaly].
     *
     * Unlike [meanAnomaly], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _meanAnomaly(): JsonField<Double> = body._meanAnomaly()

    /**
     * Returns the raw JSON value of [meanMotion].
     *
     * Unlike [meanMotion], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _meanMotion(): JsonField<Double> = body._meanMotion()

    /**
     * Returns the raw JSON value of [meanMotionDDot].
     *
     * Unlike [meanMotionDDot], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _meanMotionDDot(): JsonField<Double> = body._meanMotionDDot()

    /**
     * Returns the raw JSON value of [meanMotionDot].
     *
     * Unlike [meanMotionDot], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _meanMotionDot(): JsonField<Double> = body._meanMotionDot()

    /**
     * Returns the raw JSON value of [origin].
     *
     * Unlike [origin], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _origin(): JsonField<String> = body._origin()

    /**
     * Returns the raw JSON value of [origNetwork].
     *
     * Unlike [origNetwork], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _origNetwork(): JsonField<String> = body._origNetwork()

    /**
     * Returns the raw JSON value of [perigee].
     *
     * Unlike [perigee], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _perigee(): JsonField<Double> = body._perigee()

    /**
     * Returns the raw JSON value of [period].
     *
     * Unlike [period], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _period(): JsonField<Double> = body._period()

    /**
     * Returns the raw JSON value of [raan].
     *
     * Unlike [raan], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _raan(): JsonField<Double> = body._raan()

    /**
     * Returns the raw JSON value of [revNo].
     *
     * Unlike [revNo], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _revNo(): JsonField<Int> = body._revNo()

    /**
     * Returns the raw JSON value of [semiMajorAxis].
     *
     * Unlike [semiMajorAxis], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _semiMajorAxis(): JsonField<Double> = body._semiMajorAxis()

    fun _additionalBodyProperties(): Map<String, JsonValue> = body._additionalProperties()

    /** Additional headers to send with the request. */
    fun _additionalHeaders(): Headers = additionalHeaders

    /** Additional query param to send with the request. */
    fun _additionalQueryParams(): QueryParams = additionalQueryParams

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of [ManifoldelsetCreateParams].
         *
         * The following fields are required:
         * ```java
         * .classificationMarking()
         * .dataMode()
         * .epoch()
         * .idManifold()
         * .source()
         * .tmpSatNo()
         * ```
         */
        @JvmStatic fun builder() = Builder()
    }

    /** A builder for [ManifoldelsetCreateParams]. */
    class Builder internal constructor() {

        private var body: Body.Builder = Body.builder()
        private var additionalHeaders: Headers.Builder = Headers.builder()
        private var additionalQueryParams: QueryParams.Builder = QueryParams.builder()

        @JvmSynthetic
        internal fun from(manifoldelsetCreateParams: ManifoldelsetCreateParams) = apply {
            body = manifoldelsetCreateParams.body.toBuilder()
            additionalHeaders = manifoldelsetCreateParams.additionalHeaders.toBuilder()
            additionalQueryParams = manifoldelsetCreateParams.additionalQueryParams.toBuilder()
        }

        /**
         * Sets the entire request body.
         *
         * This is generally only useful if you are already constructing the body separately.
         * Otherwise, it's more convenient to use the top-level setters instead:
         * - [classificationMarking]
         * - [dataMode]
         * - [epoch]
         * - [idManifold]
         * - [source]
         * - etc.
         */
        fun body(body: Body) = apply { this.body = body.toBuilder() }

        /** Classification marking of the data in IC/CAPCO Portion-marked format. */
        fun classificationMarking(classificationMarking: String) = apply {
            body.classificationMarking(classificationMarking)
        }

        /**
         * Sets [Builder.classificationMarking] to an arbitrary JSON value.
         *
         * You should usually call [Builder.classificationMarking] with a well-typed [String] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun classificationMarking(classificationMarking: JsonField<String>) = apply {
            body.classificationMarking(classificationMarking)
        }

        /**
         * Indicator of whether the data is REAL, TEST, EXERCISE, or SIMULATED data:
         *
         * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and
         * analysis.
         *
         * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
         * requirements, and for validating technical, functional, and performance characteristics.
         *
         * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include
         * both real and simulated data.
         *
         * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
         */
        fun dataMode(dataMode: DataMode) = apply { body.dataMode(dataMode) }

        /**
         * Sets [Builder.dataMode] to an arbitrary JSON value.
         *
         * You should usually call [Builder.dataMode] with a well-typed [DataMode] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun dataMode(dataMode: JsonField<DataMode>) = apply { body.dataMode(dataMode) }

        /** Elset epoch time in ISO 8601 UTC format, with microsecond precision. */
        fun epoch(epoch: OffsetDateTime) = apply { body.epoch(epoch) }

        /**
         * Sets [Builder.epoch] to an arbitrary JSON value.
         *
         * You should usually call [Builder.epoch] with a well-typed [OffsetDateTime] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun epoch(epoch: JsonField<OffsetDateTime>) = apply { body.epoch(epoch) }

        /** Identifier of the parent Manifold record. */
        fun idManifold(idManifold: String) = apply { body.idManifold(idManifold) }

        /**
         * Sets [Builder.idManifold] to an arbitrary JSON value.
         *
         * You should usually call [Builder.idManifold] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun idManifold(idManifold: JsonField<String>) = apply { body.idManifold(idManifold) }

        /** Source of the data. */
        fun source(source: String) = apply { body.source(source) }

        /**
         * Sets [Builder.source] to an arbitrary JSON value.
         *
         * You should usually call [Builder.source] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun source(source: JsonField<String>) = apply { body.source(source) }

        /** A placeholder satellite number and not a true NORAD catalog number. */
        fun tmpSatNo(tmpSatNo: Int) = apply { body.tmpSatNo(tmpSatNo) }

        /**
         * Sets [Builder.tmpSatNo] to an arbitrary JSON value.
         *
         * You should usually call [Builder.tmpSatNo] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun tmpSatNo(tmpSatNo: JsonField<Int>) = apply { body.tmpSatNo(tmpSatNo) }

        /** Unique identifier of the record, auto-generated by the system. */
        fun id(id: String) = apply { body.id(id) }

        /**
         * Sets [Builder.id] to an arbitrary JSON value.
         *
         * You should usually call [Builder.id] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun id(id: JsonField<String>) = apply { body.id(id) }

        /** The Orbit point furthest from the center of the earth in kilometers. */
        fun apogee(apogee: Double) = apply { body.apogee(apogee) }

        /**
         * Sets [Builder.apogee] to an arbitrary JSON value.
         *
         * You should usually call [Builder.apogee] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun apogee(apogee: JsonField<Double>) = apply { body.apogee(apogee) }

        /**
         * The argument of perigee is the angle in degrees formed between the perigee and the
         * ascending node. If the perigee would occur at the ascending node, the argument of perigee
         * would be 0.
         */
        fun argOfPerigee(argOfPerigee: Double) = apply { body.argOfPerigee(argOfPerigee) }

        /**
         * Sets [Builder.argOfPerigee] to an arbitrary JSON value.
         *
         * You should usually call [Builder.argOfPerigee] with a well-typed [Double] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun argOfPerigee(argOfPerigee: JsonField<Double>) = apply {
            body.argOfPerigee(argOfPerigee)
        }

        /**
         * The drag term for SGP4 orbital model, used for calculating decay constants for altitude,
         * eccentricity etc, measured in inverse earth radii.
         */
        fun bStar(bStar: Double) = apply { body.bStar(bStar) }

        /**
         * Sets [Builder.bStar] to an arbitrary JSON value.
         *
         * You should usually call [Builder.bStar] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun bStar(bStar: JsonField<Double>) = apply { body.bStar(bStar) }

        /** Time the row was created in the database, auto-populated by the system. */
        fun createdAt(createdAt: OffsetDateTime) = apply { body.createdAt(createdAt) }

        /**
         * Sets [Builder.createdAt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply { body.createdAt(createdAt) }

        /** Application user who created the row in the database, auto-populated by the system. */
        fun createdBy(createdBy: String) = apply { body.createdBy(createdBy) }

        /**
         * Sets [Builder.createdBy] to an arbitrary JSON value.
         *
         * You should usually call [Builder.createdBy] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun createdBy(createdBy: JsonField<String>) = apply { body.createdBy(createdBy) }

        /**
         * The orbital eccentricity of an astronomical object is a parameter that determines the
         * amount by which its orbit around another body deviates from a perfect circle. A value of
         * 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic
         * escape orbit, and greater than 1 is a hyperbolic escape orbit.
         */
        fun eccentricity(eccentricity: Double) = apply { body.eccentricity(eccentricity) }

        /**
         * Sets [Builder.eccentricity] to an arbitrary JSON value.
         *
         * You should usually call [Builder.eccentricity] with a well-typed [Double] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun eccentricity(eccentricity: JsonField<Double>) = apply {
            body.eccentricity(eccentricity)
        }

        /**
         * The angle between the equator and the orbit when looking from the center of the Earth. If
         * the orbit went exactly around the equator from left to right, then the inclination would
         * be 0. The inclination ranges from 0 to 180 degrees.
         */
        fun inclination(inclination: Double) = apply { body.inclination(inclination) }

        /**
         * Sets [Builder.inclination] to an arbitrary JSON value.
         *
         * You should usually call [Builder.inclination] with a well-typed [Double] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun inclination(inclination: JsonField<Double>) = apply { body.inclination(inclination) }

        /**
         * Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored
         * on create/edit operations.
         */
        fun line1(line1: String) = apply { body.line1(line1) }

        /**
         * Sets [Builder.line1] to an arbitrary JSON value.
         *
         * You should usually call [Builder.line1] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun line1(line1: JsonField<String>) = apply { body.line1(line1) }

        /**
         * Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored
         * on create/edit operations.
         */
        fun line2(line2: String) = apply { body.line2(line2) }

        /**
         * Sets [Builder.line2] to an arbitrary JSON value.
         *
         * You should usually call [Builder.line2] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun line2(line2: JsonField<String>) = apply { body.line2(line2) }

        /**
         * Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360
         * degrees. The mean anomaly is referenced to the perigee. If the satellite were at the
         * perigee, the mean anomaly would be 0.
         */
        fun meanAnomaly(meanAnomaly: Double) = apply { body.meanAnomaly(meanAnomaly) }

        /**
         * Sets [Builder.meanAnomaly] to an arbitrary JSON value.
         *
         * You should usually call [Builder.meanAnomaly] with a well-typed [Double] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun meanAnomaly(meanAnomaly: JsonField<Double>) = apply { body.meanAnomaly(meanAnomaly) }

        /**
         * The constant angular speed required for the body to complete one circular orbit in the
         * same amount of time as the actual elliptical orbit with variable speed. Measured in
         * revolutions per day.
         */
        fun meanMotion(meanMotion: Double) = apply { body.meanMotion(meanMotion) }

        /**
         * Sets [Builder.meanMotion] to an arbitrary JSON value.
         *
         * You should usually call [Builder.meanMotion] with a well-typed [Double] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun meanMotion(meanMotion: JsonField<Double>) = apply { body.meanMotion(meanMotion) }

        /**
         * 2nd derivative of the mean motion with respect to time. Units are revolutions per day
         * cubed.
         */
        fun meanMotionDDot(meanMotionDDot: Double) = apply { body.meanMotionDDot(meanMotionDDot) }

        /**
         * Sets [Builder.meanMotionDDot] to an arbitrary JSON value.
         *
         * You should usually call [Builder.meanMotionDDot] with a well-typed [Double] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun meanMotionDDot(meanMotionDDot: JsonField<Double>) = apply {
            body.meanMotionDDot(meanMotionDDot)
        }

        /**
         * 1st derivative of the mean motion with respect to time. Units are revolutions per day
         * squared.
         */
        fun meanMotionDot(meanMotionDot: Double) = apply { body.meanMotionDot(meanMotionDot) }

        /**
         * Sets [Builder.meanMotionDot] to an arbitrary JSON value.
         *
         * You should usually call [Builder.meanMotionDot] with a well-typed [Double] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun meanMotionDot(meanMotionDot: JsonField<Double>) = apply {
            body.meanMotionDot(meanMotionDot)
        }

        /**
         * Originating system or organization which produced the data, if different from the source.
         * The origin may be different than the source if the source was a mediating system which
         * forwarded the data on behalf of the origin system. If null, the source may be assumed to
         * be the origin.
         */
        fun origin(origin: String) = apply { body.origin(origin) }

        /**
         * Sets [Builder.origin] to an arbitrary JSON value.
         *
         * You should usually call [Builder.origin] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun origin(origin: JsonField<String>) = apply { body.origin(origin) }

        /**
         * The originating source network on which this record was created, auto-populated by the
         * system.
         */
        fun origNetwork(origNetwork: String) = apply { body.origNetwork(origNetwork) }

        /**
         * Sets [Builder.origNetwork] to an arbitrary JSON value.
         *
         * You should usually call [Builder.origNetwork] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun origNetwork(origNetwork: JsonField<String>) = apply { body.origNetwork(origNetwork) }

        /** The orbit point nearest to the center of the earth in kilometers. */
        fun perigee(perigee: Double) = apply { body.perigee(perigee) }

        /**
         * Sets [Builder.perigee] to an arbitrary JSON value.
         *
         * You should usually call [Builder.perigee] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun perigee(perigee: JsonField<Double>) = apply { body.perigee(perigee) }

        /** Period of the orbit equal to inverse of mean motion. */
        fun period(period: Double) = apply { body.period(period) }

        /**
         * Sets [Builder.period] to an arbitrary JSON value.
         *
         * You should usually call [Builder.period] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun period(period: JsonField<Double>) = apply { body.period(period) }

        /**
         * Right ascension of the ascending node, or RAAN is the angle as measured in degrees
         * eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to
         * the ascending node, which is where the orbit crosses the equator when traveling north.
         */
        fun raan(raan: Double) = apply { body.raan(raan) }

        /**
         * Sets [Builder.raan] to an arbitrary JSON value.
         *
         * You should usually call [Builder.raan] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun raan(raan: JsonField<Double>) = apply { body.raan(raan) }

        /**
         * The current revolution number. The value is incremented when a satellite crosses the
         * equator on an ascending pass.
         */
        fun revNo(revNo: Int) = apply { body.revNo(revNo) }

        /**
         * Sets [Builder.revNo] to an arbitrary JSON value.
         *
         * You should usually call [Builder.revNo] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun revNo(revNo: JsonField<Int>) = apply { body.revNo(revNo) }

        /**
         * The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the
         * semimajor axis is the distance between the centers of the bodies, not the distance of the
         * bodies from the center of mass.
         */
        fun semiMajorAxis(semiMajorAxis: Double) = apply { body.semiMajorAxis(semiMajorAxis) }

        /**
         * Sets [Builder.semiMajorAxis] to an arbitrary JSON value.
         *
         * You should usually call [Builder.semiMajorAxis] with a well-typed [Double] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun semiMajorAxis(semiMajorAxis: JsonField<Double>) = apply {
            body.semiMajorAxis(semiMajorAxis)
        }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            body.additionalProperties(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            body.putAdditionalProperty(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                body.putAllAdditionalProperties(additionalBodyProperties)
            }

        fun removeAdditionalBodyProperty(key: String) = apply { body.removeAdditionalProperty(key) }

        fun removeAllAdditionalBodyProperties(keys: Set<String>) = apply {
            body.removeAllAdditionalProperties(keys)
        }

        fun additionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun putAdditionalHeader(name: String, value: String) = apply {
            additionalHeaders.put(name, value)
        }

        fun putAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.put(name, values)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun replaceAdditionalHeaders(name: String, value: String) = apply {
            additionalHeaders.replace(name, value)
        }

        fun replaceAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.replace(name, values)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun removeAdditionalHeaders(name: String) = apply { additionalHeaders.remove(name) }

        fun removeAllAdditionalHeaders(names: Set<String>) = apply {
            additionalHeaders.removeAll(names)
        }

        fun additionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun putAdditionalQueryParam(key: String, value: String) = apply {
            additionalQueryParams.put(key, value)
        }

        fun putAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.put(key, values)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.putAll(additionalQueryParams)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.putAll(additionalQueryParams)
            }

        fun replaceAdditionalQueryParams(key: String, value: String) = apply {
            additionalQueryParams.replace(key, value)
        }

        fun replaceAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.replace(key, values)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.replaceAll(additionalQueryParams)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.replaceAll(additionalQueryParams)
            }

        fun removeAdditionalQueryParams(key: String) = apply { additionalQueryParams.remove(key) }

        fun removeAllAdditionalQueryParams(keys: Set<String>) = apply {
            additionalQueryParams.removeAll(keys)
        }

        /**
         * Returns an immutable instance of [ManifoldelsetCreateParams].
         *
         * Further updates to this [Builder] will not mutate the returned instance.
         *
         * The following fields are required:
         * ```java
         * .classificationMarking()
         * .dataMode()
         * .epoch()
         * .idManifold()
         * .source()
         * .tmpSatNo()
         * ```
         *
         * @throws IllegalStateException if any required field is unset.
         */
        fun build(): ManifoldelsetCreateParams =
            ManifoldelsetCreateParams(
                body.build(),
                additionalHeaders.build(),
                additionalQueryParams.build(),
            )
    }

    fun _body(): Body = body

    override fun _headers(): Headers = additionalHeaders

    override fun _queryParams(): QueryParams = additionalQueryParams

    /**
     * Theoretical Keplarian orbital elements belonging to an object of interest's manifold
     * describing a possible/theoretical orbit for an object of interest for tasking purposes.
     */
    class Body
    @JsonCreator(mode = JsonCreator.Mode.DISABLED)
    private constructor(
        private val classificationMarking: JsonField<String>,
        private val dataMode: JsonField<DataMode>,
        private val epoch: JsonField<OffsetDateTime>,
        private val idManifold: JsonField<String>,
        private val source: JsonField<String>,
        private val tmpSatNo: JsonField<Int>,
        private val id: JsonField<String>,
        private val apogee: JsonField<Double>,
        private val argOfPerigee: JsonField<Double>,
        private val bStar: JsonField<Double>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val createdBy: JsonField<String>,
        private val eccentricity: JsonField<Double>,
        private val inclination: JsonField<Double>,
        private val line1: JsonField<String>,
        private val line2: JsonField<String>,
        private val meanAnomaly: JsonField<Double>,
        private val meanMotion: JsonField<Double>,
        private val meanMotionDDot: JsonField<Double>,
        private val meanMotionDot: JsonField<Double>,
        private val origin: JsonField<String>,
        private val origNetwork: JsonField<String>,
        private val perigee: JsonField<Double>,
        private val period: JsonField<Double>,
        private val raan: JsonField<Double>,
        private val revNo: JsonField<Int>,
        private val semiMajorAxis: JsonField<Double>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("classificationMarking")
            @ExcludeMissing
            classificationMarking: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dataMode")
            @ExcludeMissing
            dataMode: JsonField<DataMode> = JsonMissing.of(),
            @JsonProperty("epoch")
            @ExcludeMissing
            epoch: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("idManifold")
            @ExcludeMissing
            idManifold: JsonField<String> = JsonMissing.of(),
            @JsonProperty("source") @ExcludeMissing source: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tmpSatNo") @ExcludeMissing tmpSatNo: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("apogee") @ExcludeMissing apogee: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("argOfPerigee")
            @ExcludeMissing
            argOfPerigee: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("bStar") @ExcludeMissing bStar: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("createdAt")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("createdBy")
            @ExcludeMissing
            createdBy: JsonField<String> = JsonMissing.of(),
            @JsonProperty("eccentricity")
            @ExcludeMissing
            eccentricity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("inclination")
            @ExcludeMissing
            inclination: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("line1") @ExcludeMissing line1: JsonField<String> = JsonMissing.of(),
            @JsonProperty("line2") @ExcludeMissing line2: JsonField<String> = JsonMissing.of(),
            @JsonProperty("meanAnomaly")
            @ExcludeMissing
            meanAnomaly: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("meanMotion")
            @ExcludeMissing
            meanMotion: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("meanMotionDDot")
            @ExcludeMissing
            meanMotionDDot: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("meanMotionDot")
            @ExcludeMissing
            meanMotionDot: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("origin") @ExcludeMissing origin: JsonField<String> = JsonMissing.of(),
            @JsonProperty("origNetwork")
            @ExcludeMissing
            origNetwork: JsonField<String> = JsonMissing.of(),
            @JsonProperty("perigee") @ExcludeMissing perigee: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("period") @ExcludeMissing period: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("raan") @ExcludeMissing raan: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("revNo") @ExcludeMissing revNo: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("semiMajorAxis")
            @ExcludeMissing
            semiMajorAxis: JsonField<Double> = JsonMissing.of(),
        ) : this(
            classificationMarking,
            dataMode,
            epoch,
            idManifold,
            source,
            tmpSatNo,
            id,
            apogee,
            argOfPerigee,
            bStar,
            createdAt,
            createdBy,
            eccentricity,
            inclination,
            line1,
            line2,
            meanAnomaly,
            meanMotion,
            meanMotionDDot,
            meanMotionDot,
            origin,
            origNetwork,
            perigee,
            period,
            raan,
            revNo,
            semiMajorAxis,
            mutableMapOf(),
        )

        /**
         * Classification marking of the data in IC/CAPCO Portion-marked format.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun classificationMarking(): String =
            classificationMarking.getRequired("classificationMarking")

        /**
         * Indicator of whether the data is REAL, TEST, EXERCISE, or SIMULATED data:
         *
         * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and
         * analysis.
         *
         * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
         * requirements, and for validating technical, functional, and performance characteristics.
         *
         * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include
         * both real and simulated data.
         *
         * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun dataMode(): DataMode = dataMode.getRequired("dataMode")

        /**
         * Elset epoch time in ISO 8601 UTC format, with microsecond precision.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun epoch(): OffsetDateTime = epoch.getRequired("epoch")

        /**
         * Identifier of the parent Manifold record.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun idManifold(): String = idManifold.getRequired("idManifold")

        /**
         * Source of the data.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun source(): String = source.getRequired("source")

        /**
         * A placeholder satellite number and not a true NORAD catalog number.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun tmpSatNo(): Int = tmpSatNo.getRequired("tmpSatNo")

        /**
         * Unique identifier of the record, auto-generated by the system.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun id(): Optional<String> = id.getOptional("id")

        /**
         * The Orbit point furthest from the center of the earth in kilometers.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun apogee(): Optional<Double> = apogee.getOptional("apogee")

        /**
         * The argument of perigee is the angle in degrees formed between the perigee and the
         * ascending node. If the perigee would occur at the ascending node, the argument of perigee
         * would be 0.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun argOfPerigee(): Optional<Double> = argOfPerigee.getOptional("argOfPerigee")

        /**
         * The drag term for SGP4 orbital model, used for calculating decay constants for altitude,
         * eccentricity etc, measured in inverse earth radii.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun bStar(): Optional<Double> = bStar.getOptional("bStar")

        /**
         * Time the row was created in the database, auto-populated by the system.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): Optional<OffsetDateTime> = createdAt.getOptional("createdAt")

        /**
         * Application user who created the row in the database, auto-populated by the system.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun createdBy(): Optional<String> = createdBy.getOptional("createdBy")

        /**
         * The orbital eccentricity of an astronomical object is a parameter that determines the
         * amount by which its orbit around another body deviates from a perfect circle. A value of
         * 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic
         * escape orbit, and greater than 1 is a hyperbolic escape orbit.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun eccentricity(): Optional<Double> = eccentricity.getOptional("eccentricity")

        /**
         * The angle between the equator and the orbit when looking from the center of the Earth. If
         * the orbit went exactly around the equator from left to right, then the inclination would
         * be 0. The inclination ranges from 0 to 180 degrees.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun inclination(): Optional<Double> = inclination.getOptional("inclination")

        /**
         * Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored
         * on create/edit operations.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun line1(): Optional<String> = line1.getOptional("line1")

        /**
         * Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored
         * on create/edit operations.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun line2(): Optional<String> = line2.getOptional("line2")

        /**
         * Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360
         * degrees. The mean anomaly is referenced to the perigee. If the satellite were at the
         * perigee, the mean anomaly would be 0.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun meanAnomaly(): Optional<Double> = meanAnomaly.getOptional("meanAnomaly")

        /**
         * The constant angular speed required for the body to complete one circular orbit in the
         * same amount of time as the actual elliptical orbit with variable speed. Measured in
         * revolutions per day.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun meanMotion(): Optional<Double> = meanMotion.getOptional("meanMotion")

        /**
         * 2nd derivative of the mean motion with respect to time. Units are revolutions per day
         * cubed.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun meanMotionDDot(): Optional<Double> = meanMotionDDot.getOptional("meanMotionDDot")

        /**
         * 1st derivative of the mean motion with respect to time. Units are revolutions per day
         * squared.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun meanMotionDot(): Optional<Double> = meanMotionDot.getOptional("meanMotionDot")

        /**
         * Originating system or organization which produced the data, if different from the source.
         * The origin may be different than the source if the source was a mediating system which
         * forwarded the data on behalf of the origin system. If null, the source may be assumed to
         * be the origin.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun origin(): Optional<String> = origin.getOptional("origin")

        /**
         * The originating source network on which this record was created, auto-populated by the
         * system.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun origNetwork(): Optional<String> = origNetwork.getOptional("origNetwork")

        /**
         * The orbit point nearest to the center of the earth in kilometers.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun perigee(): Optional<Double> = perigee.getOptional("perigee")

        /**
         * Period of the orbit equal to inverse of mean motion.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun period(): Optional<Double> = period.getOptional("period")

        /**
         * Right ascension of the ascending node, or RAAN is the angle as measured in degrees
         * eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to
         * the ascending node, which is where the orbit crosses the equator when traveling north.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun raan(): Optional<Double> = raan.getOptional("raan")

        /**
         * The current revolution number. The value is incremented when a satellite crosses the
         * equator on an ascending pass.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun revNo(): Optional<Int> = revNo.getOptional("revNo")

        /**
         * The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the
         * semimajor axis is the distance between the centers of the bodies, not the distance of the
         * bodies from the center of mass.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun semiMajorAxis(): Optional<Double> = semiMajorAxis.getOptional("semiMajorAxis")

        /**
         * Returns the raw JSON value of [classificationMarking].
         *
         * Unlike [classificationMarking], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("classificationMarking")
        @ExcludeMissing
        fun _classificationMarking(): JsonField<String> = classificationMarking

        /**
         * Returns the raw JSON value of [dataMode].
         *
         * Unlike [dataMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("dataMode") @ExcludeMissing fun _dataMode(): JsonField<DataMode> = dataMode

        /**
         * Returns the raw JSON value of [epoch].
         *
         * Unlike [epoch], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("epoch") @ExcludeMissing fun _epoch(): JsonField<OffsetDateTime> = epoch

        /**
         * Returns the raw JSON value of [idManifold].
         *
         * Unlike [idManifold], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("idManifold")
        @ExcludeMissing
        fun _idManifold(): JsonField<String> = idManifold

        /**
         * Returns the raw JSON value of [source].
         *
         * Unlike [source], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("source") @ExcludeMissing fun _source(): JsonField<String> = source

        /**
         * Returns the raw JSON value of [tmpSatNo].
         *
         * Unlike [tmpSatNo], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("tmpSatNo") @ExcludeMissing fun _tmpSatNo(): JsonField<Int> = tmpSatNo

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [apogee].
         *
         * Unlike [apogee], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("apogee") @ExcludeMissing fun _apogee(): JsonField<Double> = apogee

        /**
         * Returns the raw JSON value of [argOfPerigee].
         *
         * Unlike [argOfPerigee], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("argOfPerigee")
        @ExcludeMissing
        fun _argOfPerigee(): JsonField<Double> = argOfPerigee

        /**
         * Returns the raw JSON value of [bStar].
         *
         * Unlike [bStar], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("bStar") @ExcludeMissing fun _bStar(): JsonField<Double> = bStar

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("createdAt")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [createdBy].
         *
         * Unlike [createdBy], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("createdBy") @ExcludeMissing fun _createdBy(): JsonField<String> = createdBy

        /**
         * Returns the raw JSON value of [eccentricity].
         *
         * Unlike [eccentricity], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("eccentricity")
        @ExcludeMissing
        fun _eccentricity(): JsonField<Double> = eccentricity

        /**
         * Returns the raw JSON value of [inclination].
         *
         * Unlike [inclination], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("inclination")
        @ExcludeMissing
        fun _inclination(): JsonField<Double> = inclination

        /**
         * Returns the raw JSON value of [line1].
         *
         * Unlike [line1], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("line1") @ExcludeMissing fun _line1(): JsonField<String> = line1

        /**
         * Returns the raw JSON value of [line2].
         *
         * Unlike [line2], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("line2") @ExcludeMissing fun _line2(): JsonField<String> = line2

        /**
         * Returns the raw JSON value of [meanAnomaly].
         *
         * Unlike [meanAnomaly], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("meanAnomaly")
        @ExcludeMissing
        fun _meanAnomaly(): JsonField<Double> = meanAnomaly

        /**
         * Returns the raw JSON value of [meanMotion].
         *
         * Unlike [meanMotion], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("meanMotion")
        @ExcludeMissing
        fun _meanMotion(): JsonField<Double> = meanMotion

        /**
         * Returns the raw JSON value of [meanMotionDDot].
         *
         * Unlike [meanMotionDDot], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("meanMotionDDot")
        @ExcludeMissing
        fun _meanMotionDDot(): JsonField<Double> = meanMotionDDot

        /**
         * Returns the raw JSON value of [meanMotionDot].
         *
         * Unlike [meanMotionDot], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("meanMotionDot")
        @ExcludeMissing
        fun _meanMotionDot(): JsonField<Double> = meanMotionDot

        /**
         * Returns the raw JSON value of [origin].
         *
         * Unlike [origin], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("origin") @ExcludeMissing fun _origin(): JsonField<String> = origin

        /**
         * Returns the raw JSON value of [origNetwork].
         *
         * Unlike [origNetwork], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("origNetwork")
        @ExcludeMissing
        fun _origNetwork(): JsonField<String> = origNetwork

        /**
         * Returns the raw JSON value of [perigee].
         *
         * Unlike [perigee], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("perigee") @ExcludeMissing fun _perigee(): JsonField<Double> = perigee

        /**
         * Returns the raw JSON value of [period].
         *
         * Unlike [period], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("period") @ExcludeMissing fun _period(): JsonField<Double> = period

        /**
         * Returns the raw JSON value of [raan].
         *
         * Unlike [raan], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("raan") @ExcludeMissing fun _raan(): JsonField<Double> = raan

        /**
         * Returns the raw JSON value of [revNo].
         *
         * Unlike [revNo], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("revNo") @ExcludeMissing fun _revNo(): JsonField<Int> = revNo

        /**
         * Returns the raw JSON value of [semiMajorAxis].
         *
         * Unlike [semiMajorAxis], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("semiMajorAxis")
        @ExcludeMissing
        fun _semiMajorAxis(): JsonField<Double> = semiMajorAxis

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Body].
             *
             * The following fields are required:
             * ```java
             * .classificationMarking()
             * .dataMode()
             * .epoch()
             * .idManifold()
             * .source()
             * .tmpSatNo()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Body]. */
        class Builder internal constructor() {

            private var classificationMarking: JsonField<String>? = null
            private var dataMode: JsonField<DataMode>? = null
            private var epoch: JsonField<OffsetDateTime>? = null
            private var idManifold: JsonField<String>? = null
            private var source: JsonField<String>? = null
            private var tmpSatNo: JsonField<Int>? = null
            private var id: JsonField<String> = JsonMissing.of()
            private var apogee: JsonField<Double> = JsonMissing.of()
            private var argOfPerigee: JsonField<Double> = JsonMissing.of()
            private var bStar: JsonField<Double> = JsonMissing.of()
            private var createdAt: JsonField<OffsetDateTime> = JsonMissing.of()
            private var createdBy: JsonField<String> = JsonMissing.of()
            private var eccentricity: JsonField<Double> = JsonMissing.of()
            private var inclination: JsonField<Double> = JsonMissing.of()
            private var line1: JsonField<String> = JsonMissing.of()
            private var line2: JsonField<String> = JsonMissing.of()
            private var meanAnomaly: JsonField<Double> = JsonMissing.of()
            private var meanMotion: JsonField<Double> = JsonMissing.of()
            private var meanMotionDDot: JsonField<Double> = JsonMissing.of()
            private var meanMotionDot: JsonField<Double> = JsonMissing.of()
            private var origin: JsonField<String> = JsonMissing.of()
            private var origNetwork: JsonField<String> = JsonMissing.of()
            private var perigee: JsonField<Double> = JsonMissing.of()
            private var period: JsonField<Double> = JsonMissing.of()
            private var raan: JsonField<Double> = JsonMissing.of()
            private var revNo: JsonField<Int> = JsonMissing.of()
            private var semiMajorAxis: JsonField<Double> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(body: Body) = apply {
                classificationMarking = body.classificationMarking
                dataMode = body.dataMode
                epoch = body.epoch
                idManifold = body.idManifold
                source = body.source
                tmpSatNo = body.tmpSatNo
                id = body.id
                apogee = body.apogee
                argOfPerigee = body.argOfPerigee
                bStar = body.bStar
                createdAt = body.createdAt
                createdBy = body.createdBy
                eccentricity = body.eccentricity
                inclination = body.inclination
                line1 = body.line1
                line2 = body.line2
                meanAnomaly = body.meanAnomaly
                meanMotion = body.meanMotion
                meanMotionDDot = body.meanMotionDDot
                meanMotionDot = body.meanMotionDot
                origin = body.origin
                origNetwork = body.origNetwork
                perigee = body.perigee
                period = body.period
                raan = body.raan
                revNo = body.revNo
                semiMajorAxis = body.semiMajorAxis
                additionalProperties = body.additionalProperties.toMutableMap()
            }

            /** Classification marking of the data in IC/CAPCO Portion-marked format. */
            fun classificationMarking(classificationMarking: String) =
                classificationMarking(JsonField.of(classificationMarking))

            /**
             * Sets [Builder.classificationMarking] to an arbitrary JSON value.
             *
             * You should usually call [Builder.classificationMarking] with a well-typed [String]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun classificationMarking(classificationMarking: JsonField<String>) = apply {
                this.classificationMarking = classificationMarking
            }

            /**
             * Indicator of whether the data is REAL, TEST, EXERCISE, or SIMULATED data:
             *
             * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events,
             * and analysis.
             *
             * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
             * requirements, and for validating technical, functional, and performance
             * characteristics.
             *
             * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may
             * include both real and simulated data.
             *
             * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
             */
            fun dataMode(dataMode: DataMode) = dataMode(JsonField.of(dataMode))

            /**
             * Sets [Builder.dataMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dataMode] with a well-typed [DataMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun dataMode(dataMode: JsonField<DataMode>) = apply { this.dataMode = dataMode }

            /** Elset epoch time in ISO 8601 UTC format, with microsecond precision. */
            fun epoch(epoch: OffsetDateTime) = epoch(JsonField.of(epoch))

            /**
             * Sets [Builder.epoch] to an arbitrary JSON value.
             *
             * You should usually call [Builder.epoch] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun epoch(epoch: JsonField<OffsetDateTime>) = apply { this.epoch = epoch }

            /** Identifier of the parent Manifold record. */
            fun idManifold(idManifold: String) = idManifold(JsonField.of(idManifold))

            /**
             * Sets [Builder.idManifold] to an arbitrary JSON value.
             *
             * You should usually call [Builder.idManifold] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun idManifold(idManifold: JsonField<String>) = apply { this.idManifold = idManifold }

            /** Source of the data. */
            fun source(source: String) = source(JsonField.of(source))

            /**
             * Sets [Builder.source] to an arbitrary JSON value.
             *
             * You should usually call [Builder.source] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun source(source: JsonField<String>) = apply { this.source = source }

            /** A placeholder satellite number and not a true NORAD catalog number. */
            fun tmpSatNo(tmpSatNo: Int) = tmpSatNo(JsonField.of(tmpSatNo))

            /**
             * Sets [Builder.tmpSatNo] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tmpSatNo] with a well-typed [Int] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun tmpSatNo(tmpSatNo: JsonField<Int>) = apply { this.tmpSatNo = tmpSatNo }

            /** Unique identifier of the record, auto-generated by the system. */
            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            /** The Orbit point furthest from the center of the earth in kilometers. */
            fun apogee(apogee: Double) = apogee(JsonField.of(apogee))

            /**
             * Sets [Builder.apogee] to an arbitrary JSON value.
             *
             * You should usually call [Builder.apogee] with a well-typed [Double] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun apogee(apogee: JsonField<Double>) = apply { this.apogee = apogee }

            /**
             * The argument of perigee is the angle in degrees formed between the perigee and the
             * ascending node. If the perigee would occur at the ascending node, the argument of
             * perigee would be 0.
             */
            fun argOfPerigee(argOfPerigee: Double) = argOfPerigee(JsonField.of(argOfPerigee))

            /**
             * Sets [Builder.argOfPerigee] to an arbitrary JSON value.
             *
             * You should usually call [Builder.argOfPerigee] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun argOfPerigee(argOfPerigee: JsonField<Double>) = apply {
                this.argOfPerigee = argOfPerigee
            }

            /**
             * The drag term for SGP4 orbital model, used for calculating decay constants for
             * altitude, eccentricity etc, measured in inverse earth radii.
             */
            fun bStar(bStar: Double) = bStar(JsonField.of(bStar))

            /**
             * Sets [Builder.bStar] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bStar] with a well-typed [Double] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun bStar(bStar: JsonField<Double>) = apply { this.bStar = bStar }

            /** Time the row was created in the database, auto-populated by the system. */
            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            /**
             * Application user who created the row in the database, auto-populated by the system.
             */
            fun createdBy(createdBy: String) = createdBy(JsonField.of(createdBy))

            /**
             * Sets [Builder.createdBy] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdBy] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdBy(createdBy: JsonField<String>) = apply { this.createdBy = createdBy }

            /**
             * The orbital eccentricity of an astronomical object is a parameter that determines the
             * amount by which its orbit around another body deviates from a perfect circle. A value
             * of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a
             * parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
             */
            fun eccentricity(eccentricity: Double) = eccentricity(JsonField.of(eccentricity))

            /**
             * Sets [Builder.eccentricity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.eccentricity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun eccentricity(eccentricity: JsonField<Double>) = apply {
                this.eccentricity = eccentricity
            }

            /**
             * The angle between the equator and the orbit when looking from the center of the
             * Earth. If the orbit went exactly around the equator from left to right, then the
             * inclination would be 0. The inclination ranges from 0 to 180 degrees.
             */
            fun inclination(inclination: Double) = inclination(JsonField.of(inclination))

            /**
             * Sets [Builder.inclination] to an arbitrary JSON value.
             *
             * You should usually call [Builder.inclination] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun inclination(inclination: JsonField<Double>) = apply {
                this.inclination = inclination
            }

            /**
             * Read only derived/generated line1 of a legacy TLE (two line element set) format,
             * ignored on create/edit operations.
             */
            fun line1(line1: String) = line1(JsonField.of(line1))

            /**
             * Sets [Builder.line1] to an arbitrary JSON value.
             *
             * You should usually call [Builder.line1] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun line1(line1: JsonField<String>) = apply { this.line1 = line1 }

            /**
             * Read only derived/generated line2 of a legacy TLE (two line element set) format,
             * ignored on create/edit operations.
             */
            fun line2(line2: String) = line2(JsonField.of(line2))

            /**
             * Sets [Builder.line2] to an arbitrary JSON value.
             *
             * You should usually call [Builder.line2] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun line2(line2: JsonField<String>) = apply { this.line2 = line2 }

            /**
             * Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360
             * degrees. The mean anomaly is referenced to the perigee. If the satellite were at the
             * perigee, the mean anomaly would be 0.
             */
            fun meanAnomaly(meanAnomaly: Double) = meanAnomaly(JsonField.of(meanAnomaly))

            /**
             * Sets [Builder.meanAnomaly] to an arbitrary JSON value.
             *
             * You should usually call [Builder.meanAnomaly] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun meanAnomaly(meanAnomaly: JsonField<Double>) = apply {
                this.meanAnomaly = meanAnomaly
            }

            /**
             * The constant angular speed required for the body to complete one circular orbit in
             * the same amount of time as the actual elliptical orbit with variable speed. Measured
             * in revolutions per day.
             */
            fun meanMotion(meanMotion: Double) = meanMotion(JsonField.of(meanMotion))

            /**
             * Sets [Builder.meanMotion] to an arbitrary JSON value.
             *
             * You should usually call [Builder.meanMotion] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun meanMotion(meanMotion: JsonField<Double>) = apply { this.meanMotion = meanMotion }

            /**
             * 2nd derivative of the mean motion with respect to time. Units are revolutions per day
             * cubed.
             */
            fun meanMotionDDot(meanMotionDDot: Double) =
                meanMotionDDot(JsonField.of(meanMotionDDot))

            /**
             * Sets [Builder.meanMotionDDot] to an arbitrary JSON value.
             *
             * You should usually call [Builder.meanMotionDDot] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun meanMotionDDot(meanMotionDDot: JsonField<Double>) = apply {
                this.meanMotionDDot = meanMotionDDot
            }

            /**
             * 1st derivative of the mean motion with respect to time. Units are revolutions per day
             * squared.
             */
            fun meanMotionDot(meanMotionDot: Double) = meanMotionDot(JsonField.of(meanMotionDot))

            /**
             * Sets [Builder.meanMotionDot] to an arbitrary JSON value.
             *
             * You should usually call [Builder.meanMotionDot] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun meanMotionDot(meanMotionDot: JsonField<Double>) = apply {
                this.meanMotionDot = meanMotionDot
            }

            /**
             * Originating system or organization which produced the data, if different from the
             * source. The origin may be different than the source if the source was a mediating
             * system which forwarded the data on behalf of the origin system. If null, the source
             * may be assumed to be the origin.
             */
            fun origin(origin: String) = origin(JsonField.of(origin))

            /**
             * Sets [Builder.origin] to an arbitrary JSON value.
             *
             * You should usually call [Builder.origin] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun origin(origin: JsonField<String>) = apply { this.origin = origin }

            /**
             * The originating source network on which this record was created, auto-populated by
             * the system.
             */
            fun origNetwork(origNetwork: String) = origNetwork(JsonField.of(origNetwork))

            /**
             * Sets [Builder.origNetwork] to an arbitrary JSON value.
             *
             * You should usually call [Builder.origNetwork] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun origNetwork(origNetwork: JsonField<String>) = apply {
                this.origNetwork = origNetwork
            }

            /** The orbit point nearest to the center of the earth in kilometers. */
            fun perigee(perigee: Double) = perigee(JsonField.of(perigee))

            /**
             * Sets [Builder.perigee] to an arbitrary JSON value.
             *
             * You should usually call [Builder.perigee] with a well-typed [Double] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun perigee(perigee: JsonField<Double>) = apply { this.perigee = perigee }

            /** Period of the orbit equal to inverse of mean motion. */
            fun period(period: Double) = period(JsonField.of(period))

            /**
             * Sets [Builder.period] to an arbitrary JSON value.
             *
             * You should usually call [Builder.period] with a well-typed [Double] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun period(period: JsonField<Double>) = apply { this.period = period }

            /**
             * Right ascension of the ascending node, or RAAN is the angle as measured in degrees
             * eastwards (or, as seen from the north, counterclockwise) from the First Point of
             * Aries to the ascending node, which is where the orbit crosses the equator when
             * traveling north.
             */
            fun raan(raan: Double) = raan(JsonField.of(raan))

            /**
             * Sets [Builder.raan] to an arbitrary JSON value.
             *
             * You should usually call [Builder.raan] with a well-typed [Double] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun raan(raan: JsonField<Double>) = apply { this.raan = raan }

            /**
             * The current revolution number. The value is incremented when a satellite crosses the
             * equator on an ascending pass.
             */
            fun revNo(revNo: Int) = revNo(JsonField.of(revNo))

            /**
             * Sets [Builder.revNo] to an arbitrary JSON value.
             *
             * You should usually call [Builder.revNo] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun revNo(revNo: JsonField<Int>) = apply { this.revNo = revNo }

            /**
             * The sum of the periapsis and apoapsis distances divided by two. For circular orbits,
             * the semimajor axis is the distance between the centers of the bodies, not the
             * distance of the bodies from the center of mass.
             */
            fun semiMajorAxis(semiMajorAxis: Double) = semiMajorAxis(JsonField.of(semiMajorAxis))

            /**
             * Sets [Builder.semiMajorAxis] to an arbitrary JSON value.
             *
             * You should usually call [Builder.semiMajorAxis] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun semiMajorAxis(semiMajorAxis: JsonField<Double>) = apply {
                this.semiMajorAxis = semiMajorAxis
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Body].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .classificationMarking()
             * .dataMode()
             * .epoch()
             * .idManifold()
             * .source()
             * .tmpSatNo()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Body =
                Body(
                    checkRequired("classificationMarking", classificationMarking),
                    checkRequired("dataMode", dataMode),
                    checkRequired("epoch", epoch),
                    checkRequired("idManifold", idManifold),
                    checkRequired("source", source),
                    checkRequired("tmpSatNo", tmpSatNo),
                    id,
                    apogee,
                    argOfPerigee,
                    bStar,
                    createdAt,
                    createdBy,
                    eccentricity,
                    inclination,
                    line1,
                    line2,
                    meanAnomaly,
                    meanMotion,
                    meanMotionDDot,
                    meanMotionDot,
                    origin,
                    origNetwork,
                    perigee,
                    period,
                    raan,
                    revNo,
                    semiMajorAxis,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Body = apply {
            if (validated) {
                return@apply
            }

            classificationMarking()
            dataMode().validate()
            epoch()
            idManifold()
            source()
            tmpSatNo()
            id()
            apogee()
            argOfPerigee()
            bStar()
            createdAt()
            createdBy()
            eccentricity()
            inclination()
            line1()
            line2()
            meanAnomaly()
            meanMotion()
            meanMotionDDot()
            meanMotionDot()
            origin()
            origNetwork()
            perigee()
            period()
            raan()
            revNo()
            semiMajorAxis()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: UnifieddatalibraryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (classificationMarking.asKnown().isPresent) 1 else 0) +
                (dataMode.asKnown().getOrNull()?.validity() ?: 0) +
                (if (epoch.asKnown().isPresent) 1 else 0) +
                (if (idManifold.asKnown().isPresent) 1 else 0) +
                (if (source.asKnown().isPresent) 1 else 0) +
                (if (tmpSatNo.asKnown().isPresent) 1 else 0) +
                (if (id.asKnown().isPresent) 1 else 0) +
                (if (apogee.asKnown().isPresent) 1 else 0) +
                (if (argOfPerigee.asKnown().isPresent) 1 else 0) +
                (if (bStar.asKnown().isPresent) 1 else 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (if (createdBy.asKnown().isPresent) 1 else 0) +
                (if (eccentricity.asKnown().isPresent) 1 else 0) +
                (if (inclination.asKnown().isPresent) 1 else 0) +
                (if (line1.asKnown().isPresent) 1 else 0) +
                (if (line2.asKnown().isPresent) 1 else 0) +
                (if (meanAnomaly.asKnown().isPresent) 1 else 0) +
                (if (meanMotion.asKnown().isPresent) 1 else 0) +
                (if (meanMotionDDot.asKnown().isPresent) 1 else 0) +
                (if (meanMotionDot.asKnown().isPresent) 1 else 0) +
                (if (origin.asKnown().isPresent) 1 else 0) +
                (if (origNetwork.asKnown().isPresent) 1 else 0) +
                (if (perigee.asKnown().isPresent) 1 else 0) +
                (if (period.asKnown().isPresent) 1 else 0) +
                (if (raan.asKnown().isPresent) 1 else 0) +
                (if (revNo.asKnown().isPresent) 1 else 0) +
                (if (semiMajorAxis.asKnown().isPresent) 1 else 0)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is Body &&
                classificationMarking == other.classificationMarking &&
                dataMode == other.dataMode &&
                epoch == other.epoch &&
                idManifold == other.idManifold &&
                source == other.source &&
                tmpSatNo == other.tmpSatNo &&
                id == other.id &&
                apogee == other.apogee &&
                argOfPerigee == other.argOfPerigee &&
                bStar == other.bStar &&
                createdAt == other.createdAt &&
                createdBy == other.createdBy &&
                eccentricity == other.eccentricity &&
                inclination == other.inclination &&
                line1 == other.line1 &&
                line2 == other.line2 &&
                meanAnomaly == other.meanAnomaly &&
                meanMotion == other.meanMotion &&
                meanMotionDDot == other.meanMotionDDot &&
                meanMotionDot == other.meanMotionDot &&
                origin == other.origin &&
                origNetwork == other.origNetwork &&
                perigee == other.perigee &&
                period == other.period &&
                raan == other.raan &&
                revNo == other.revNo &&
                semiMajorAxis == other.semiMajorAxis &&
                additionalProperties == other.additionalProperties
        }

        private val hashCode: Int by lazy {
            Objects.hash(
                classificationMarking,
                dataMode,
                epoch,
                idManifold,
                source,
                tmpSatNo,
                id,
                apogee,
                argOfPerigee,
                bStar,
                createdAt,
                createdBy,
                eccentricity,
                inclination,
                line1,
                line2,
                meanAnomaly,
                meanMotion,
                meanMotionDDot,
                meanMotionDot,
                origin,
                origNetwork,
                perigee,
                period,
                raan,
                revNo,
                semiMajorAxis,
                additionalProperties,
            )
        }

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Body{classificationMarking=$classificationMarking, dataMode=$dataMode, epoch=$epoch, idManifold=$idManifold, source=$source, tmpSatNo=$tmpSatNo, id=$id, apogee=$apogee, argOfPerigee=$argOfPerigee, bStar=$bStar, createdAt=$createdAt, createdBy=$createdBy, eccentricity=$eccentricity, inclination=$inclination, line1=$line1, line2=$line2, meanAnomaly=$meanAnomaly, meanMotion=$meanMotion, meanMotionDDot=$meanMotionDDot, meanMotionDot=$meanMotionDot, origin=$origin, origNetwork=$origNetwork, perigee=$perigee, period=$period, raan=$raan, revNo=$revNo, semiMajorAxis=$semiMajorAxis, additionalProperties=$additionalProperties}"
    }

    /**
     * Indicator of whether the data is REAL, TEST, EXERCISE, or SIMULATED data:
     *
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and
     * analysis.
     *
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
     * requirements, and for validating technical, functional, and performance characteristics.
     *
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include
     * both real and simulated data.
     *
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     */
    class DataMode @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            @JvmField val REAL = of("REAL")

            @JvmField val TEST = of("TEST")

            @JvmField val SIMULATED = of("SIMULATED")

            @JvmField val EXERCISE = of("EXERCISE")

            @JvmStatic fun of(value: String) = DataMode(JsonField.of(value))
        }

        /** An enum containing [DataMode]'s known values. */
        enum class Known {
            REAL,
            TEST,
            SIMULATED,
            EXERCISE,
        }

        /**
         * An enum containing [DataMode]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [DataMode] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            REAL,
            TEST,
            SIMULATED,
            EXERCISE,
            /** An enum member indicating that [DataMode] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                REAL -> Value.REAL
                TEST -> Value.TEST
                SIMULATED -> Value.SIMULATED
                EXERCISE -> Value.EXERCISE
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws UnifieddatalibraryInvalidDataException if this class instance's value is a not a
         *   known member.
         */
        fun known(): Known =
            when (this) {
                REAL -> Known.REAL
                TEST -> Known.TEST
                SIMULATED -> Known.SIMULATED
                EXERCISE -> Known.EXERCISE
                else -> throw UnifieddatalibraryInvalidDataException("Unknown DataMode: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws UnifieddatalibraryInvalidDataException if this class instance's value does not
         *   have the expected primitive type.
         */
        fun asString(): String =
            _value().asString().orElseThrow {
                UnifieddatalibraryInvalidDataException("Value is not a String")
            }

        private var validated: Boolean = false

        fun validate(): DataMode = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: UnifieddatalibraryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return other is DataMode && value == other.value
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return other is ManifoldelsetCreateParams &&
            body == other.body &&
            additionalHeaders == other.additionalHeaders &&
            additionalQueryParams == other.additionalQueryParams
    }

    override fun hashCode(): Int = Objects.hash(body, additionalHeaders, additionalQueryParams)

    override fun toString() =
        "ManifoldelsetCreateParams{body=$body, additionalHeaders=$additionalHeaders, additionalQueryParams=$additionalQueryParams}"
}
