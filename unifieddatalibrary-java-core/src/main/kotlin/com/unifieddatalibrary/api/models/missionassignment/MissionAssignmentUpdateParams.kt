// File generated from our OpenAPI spec by Stainless.

package com.unifieddatalibrary.api.models.missionassignment

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.unifieddatalibrary.api.core.Enum
import com.unifieddatalibrary.api.core.ExcludeMissing
import com.unifieddatalibrary.api.core.JsonField
import com.unifieddatalibrary.api.core.JsonMissing
import com.unifieddatalibrary.api.core.JsonValue
import com.unifieddatalibrary.api.core.Params
import com.unifieddatalibrary.api.core.checkRequired
import com.unifieddatalibrary.api.core.http.Headers
import com.unifieddatalibrary.api.core.http.QueryParams
import com.unifieddatalibrary.api.errors.UnifieddatalibraryInvalidDataException
import java.time.OffsetDateTime
import java.util.Collections
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/**
 * Service operation to update a single MissionAssignment. A specific role is required to perform
 * this service operation. Please contact the UDL team for assistance.
 */
class MissionAssignmentUpdateParams
private constructor(
    private val pathId: String?,
    private val body: Body,
    private val additionalHeaders: Headers,
    private val additionalQueryParams: QueryParams,
) : Params {

    fun pathId(): Optional<String> = Optional.ofNullable(pathId)

    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun classificationMarking(): String = body.classificationMarking()

    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     *
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include
     * both real and simulated data.
     *
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and
     * analysis.
     *
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     *
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
     * requirements, and for validating technical, functional, and performance characteristics.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun dataMode(): DataMode = body.dataMode()

    /**
     * The mission assignment discrete value.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun mad(): String = body.mad()

    /**
     * Source of the data.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun source(): String = body.source()

    /**
     * The timestamp of the mission data, in ISO 8601 UTC format.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type or is
     *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
     */
    fun ts(): OffsetDateTime = body.ts()

    /**
     * Unique identifier of the record, auto-generated by the system.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun bodyId(): Optional<String> = body.bodyId()

    /**
     * TARGET POSITION CONTINUATION WORD - number of associated dmpis.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c1associateddmpis(): Optional<Int> = body.c1associateddmpis()

    /**
     * TARGET DATA CONTINUATION WORD - air specific type, see TABLE B-21.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2air(): Optional<String> = body.c2air()

    /**
     * TARGET DATA CONTINUATION WORD - altitude, 100 FT, 2047=NS.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2alt(): Optional<Int> = body.c2alt()

    /**
     * TARGET DATA CONTINUATION WORD - course in increments of 1 degree.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2crs(): Optional<Int> = body.c2crs()

    /**
     * TARGET DATA CONTINUATION WORD - exercise indicator.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2exerciseindicator(): Optional<String> = body.c2exerciseindicator()

    /**
     * TARGET DATA CONTINUATION WORD - method of fire.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2exercisemof(): Optional<String> = body.c2exercisemof()

    /**
     * TARGET DATA CONTINUATION WORD - identity.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2id(): Optional<String> = body.c2id()

    /**
     * TARGET DATA CONTINUATION WORD - identity amplifying descriptor.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2idamplifyingdescriptor(): Optional<String> = body.c2idamplifyingdescriptor()

    /**
     * TARGET DATA CONTINUATION WORD - land specific type, see TABLE B-21.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2lnd(): Optional<String> = body.c2lnd()

    /**
     * TARGET DATA CONTINUATION WORD - space specific type, see TABLE B-39.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2spc(): Optional<String> = body.c2spc()

    /**
     * TARGET DATA CONTINUATION WORD - speed in 2 DM/HR, 2047=NS.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2spd(): Optional<Int> = body.c2spd()

    /**
     * TARGET DATA CONTINUATION WORD - special interest indicator.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2specialinterestindicator(): Optional<String> = body.c2specialinterestindicator()

    /**
     * TARGET DATA CONTINUATION WORD - surface specific type, see TABLE B-21.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c2sur(): Optional<String> = body.c2sur()

    /**
     * POINT LOCATION CONTINUATION WORD - elevation, 25 FT, 1023=NS.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c3elv(): Optional<Double> = body.c3elv()

    /**
     * POINT LOCATION CONTINUATION WORD - latitude, 0.0013 MINUTE.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c3lat(): Optional<Double> = body.c3lat()

    /**
     * POINT LOCATION CONTINUATION WORD - longitude, 0.0013 MINUTE.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c3lon(): Optional<Double> = body.c3lon()

    /**
     * TARGET DATA CONTINUATION WORD - point type 1.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c3ptl(): Optional<String> = body.c3ptl()

    /**
     * TARGET DATA CONTINUATION WORD - point number.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c3ptnum(): Optional<String> = body.c3ptnum()

    /**
     * SURFACE ATTACK CONTINUATION WORD - minute.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4colon(): Optional<Int> = body.c4colon()

    /**
     * SURFACE ATTACK CONTINUATION WORD - target defenses.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4def(): Optional<String> = body.c4def()

    /**
     * SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4egress(): Optional<Int> = body.c4egress()

    /**
     * SURFACE ATTACK CONTINUATION WORD - mode of delivery.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4mod(): Optional<Int> = body.c4mod()

    /**
     * SURFACE ATTACK CONTINUATION WORD - number of stores, NS=63.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4numberofstores(): Optional<Int> = body.c4numberofstores()

    /**
     * SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4runin(): Optional<Int> = body.c4runin()

    /**
     * SURFACE ATTACK CONTINUATION WORD - target type - see TABLE B-32.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4tgt(): Optional<String> = body.c4tgt()

    /**
     * SURFACE ATTACK CONTINUATION WORD - time discrete.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4timediscrete(): Optional<String> = body.c4timediscrete()

    /**
     * SURFACE ATTACK CONTINUATION WORD - hour.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4tm(): Optional<Int> = body.c4tm()

    /**
     * SURFACE ATTACK CONTINUATION WORD - type of stores.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c4typeofstores(): Optional<Int> = body.c4typeofstores()

    /**
     * SURFACE ATTACK CONTINUATION WORD - seconds in increments of 1 sec.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c5colon(): Optional<Int> = body.c5colon()

    /**
     * CONTINUATION WORD - used with c3_elv to double precision to approx 3 ft.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c5elevationlsbs(): Optional<Int> = body.c5elevationlsbs()

    /**
     * CONTINUATION WORD - hae adjustment, measured in 3.125 FT.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c5haeadj(): Optional<Int> = body.c5haeadj()

    /**
     * CONTINUATION WORD - used with c3_lat to double precision to approx 4 ft.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c5latlsb(): Optional<Int> = body.c5latlsb()

    /**
     * CONTINUATION WORD - used with c3_lon to double precision to approx 4 ft.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c5lonlsb(): Optional<Int> = body.c5lonlsb()

    /**
     * CONTINUATION WORD - target bearing.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c5tgtbrng(): Optional<Int> = body.c5tgtbrng()

    /**
     * CONTINUATION WORD - time window.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c5tw(): Optional<Int> = body.c5tw()

    /**
     * TARGETING CONTINUATION WORD - designator/seeker pulse code.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c6dspc(): Optional<String> = body.c6dspc()

    /**
     * TARGETING CONTINUATION WORD - designator/seeker pulse code type.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c6dspct(): Optional<String> = body.c6dspct()

    /**
     * TARGETING CONTINUATION WORD - first pulse/last pulse mode.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c6fplpm(): Optional<String> = body.c6fplpm()

    /**
     * TARGETING CONTINUATION WORD - index number, related, 0=NS.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c6intel(): Optional<Int> = body.c6intel()

    /**
     * TARGETING CONTINUATION WORD - laser illuminator code.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c6laser(): Optional<Int> = body.c6laser()

    /**
     * TARGETING CONTINUATION WORD - long pulse mode.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c6longpm(): Optional<String> = body.c6longpm()

    /**
     * TARGETING CONTINUATION WORD - track number, related to 3.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c6tnr3(): Optional<Int> = body.c6tnr3()

    /**
     * THIRD PARTY CONTINUATION WORD - elevation angle, 2.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c7elang2(): Optional<Double> = body.c7elang2()

    /**
     * THIRD PARTY CONTINUATION WORD - index number, third party.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c7in3p(): Optional<Int> = body.c7in3p()

    /**
     * THIRD PARTY CONTINUATION WORD - track number, index originator.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun c7tnor(): Optional<String> = body.c7tnor()

    /**
     * Time the row was created in the database, auto-populated by the system.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun createdAt(): Optional<OffsetDateTime> = body.createdAt()

    /**
     * Application user who created the row in the database, auto-populated by the system.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun createdBy(): Optional<String> = body.createdBy()

    /**
     * Environment.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun env(): Optional<String> = body.env()

    /**
     * Index number.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun index(): Optional<Int> = body.index()

    /**
     * WGS84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun lat(): Optional<Double> = body.lat()

    /**
     * WGS84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun lon(): Optional<Double> = body.lon()

    /**
     * Origin of index number.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun orginx(): Optional<String> = body.orginx()

    /**
     * Originating system or organization which produced the data, if different from the source. The
     * origin may be different than the source if the source was a mediating system which forwarded
     * the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun origin(): Optional<String> = body.origin()

    /**
     * The originating source network on which this record was created, auto-populated by the
     * system.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun origNetwork(): Optional<String> = body.origNetwork()

    /**
     * Receipt/Compliance, values from TABLE B-9.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun rc(): Optional<String> = body.rc()

    /**
     * Recurrence rate, receipt/compliance.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun rr(): Optional<Int> = body.rr()

    /**
     * Strength.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun sz(): Optional<String> = body.sz()

    /**
     * Track number objective.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun tno(): Optional<String> = body.tno()

    /**
     * The track ID that the status is referencing, addressee.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun trkId(): Optional<String> = body.trkId()

    /**
     * Threat warning environment.
     *
     * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type (e.g.
     *   if the server responded with an unexpected value).
     */
    fun twenv(): Optional<String> = body.twenv()

    /**
     * Returns the raw JSON value of [classificationMarking].
     *
     * Unlike [classificationMarking], this method doesn't throw if the JSON field has an unexpected
     * type.
     */
    fun _classificationMarking(): JsonField<String> = body._classificationMarking()

    /**
     * Returns the raw JSON value of [dataMode].
     *
     * Unlike [dataMode], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _dataMode(): JsonField<DataMode> = body._dataMode()

    /**
     * Returns the raw JSON value of [mad].
     *
     * Unlike [mad], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _mad(): JsonField<String> = body._mad()

    /**
     * Returns the raw JSON value of [source].
     *
     * Unlike [source], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _source(): JsonField<String> = body._source()

    /**
     * Returns the raw JSON value of [ts].
     *
     * Unlike [ts], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _ts(): JsonField<OffsetDateTime> = body._ts()

    /**
     * Returns the raw JSON value of [bodyId].
     *
     * Unlike [bodyId], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _bodyId(): JsonField<String> = body._bodyId()

    /**
     * Returns the raw JSON value of [c1associateddmpis].
     *
     * Unlike [c1associateddmpis], this method doesn't throw if the JSON field has an unexpected
     * type.
     */
    fun _c1associateddmpis(): JsonField<Int> = body._c1associateddmpis()

    /**
     * Returns the raw JSON value of [c2air].
     *
     * Unlike [c2air], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2air(): JsonField<String> = body._c2air()

    /**
     * Returns the raw JSON value of [c2alt].
     *
     * Unlike [c2alt], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2alt(): JsonField<Int> = body._c2alt()

    /**
     * Returns the raw JSON value of [c2crs].
     *
     * Unlike [c2crs], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2crs(): JsonField<Int> = body._c2crs()

    /**
     * Returns the raw JSON value of [c2exerciseindicator].
     *
     * Unlike [c2exerciseindicator], this method doesn't throw if the JSON field has an unexpected
     * type.
     */
    fun _c2exerciseindicator(): JsonField<String> = body._c2exerciseindicator()

    /**
     * Returns the raw JSON value of [c2exercisemof].
     *
     * Unlike [c2exercisemof], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2exercisemof(): JsonField<String> = body._c2exercisemof()

    /**
     * Returns the raw JSON value of [c2id].
     *
     * Unlike [c2id], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2id(): JsonField<String> = body._c2id()

    /**
     * Returns the raw JSON value of [c2idamplifyingdescriptor].
     *
     * Unlike [c2idamplifyingdescriptor], this method doesn't throw if the JSON field has an
     * unexpected type.
     */
    fun _c2idamplifyingdescriptor(): JsonField<String> = body._c2idamplifyingdescriptor()

    /**
     * Returns the raw JSON value of [c2lnd].
     *
     * Unlike [c2lnd], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2lnd(): JsonField<String> = body._c2lnd()

    /**
     * Returns the raw JSON value of [c2spc].
     *
     * Unlike [c2spc], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2spc(): JsonField<String> = body._c2spc()

    /**
     * Returns the raw JSON value of [c2spd].
     *
     * Unlike [c2spd], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2spd(): JsonField<Int> = body._c2spd()

    /**
     * Returns the raw JSON value of [c2specialinterestindicator].
     *
     * Unlike [c2specialinterestindicator], this method doesn't throw if the JSON field has an
     * unexpected type.
     */
    fun _c2specialinterestindicator(): JsonField<String> = body._c2specialinterestindicator()

    /**
     * Returns the raw JSON value of [c2sur].
     *
     * Unlike [c2sur], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c2sur(): JsonField<String> = body._c2sur()

    /**
     * Returns the raw JSON value of [c3elv].
     *
     * Unlike [c3elv], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c3elv(): JsonField<Double> = body._c3elv()

    /**
     * Returns the raw JSON value of [c3lat].
     *
     * Unlike [c3lat], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c3lat(): JsonField<Double> = body._c3lat()

    /**
     * Returns the raw JSON value of [c3lon].
     *
     * Unlike [c3lon], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c3lon(): JsonField<Double> = body._c3lon()

    /**
     * Returns the raw JSON value of [c3ptl].
     *
     * Unlike [c3ptl], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c3ptl(): JsonField<String> = body._c3ptl()

    /**
     * Returns the raw JSON value of [c3ptnum].
     *
     * Unlike [c3ptnum], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c3ptnum(): JsonField<String> = body._c3ptnum()

    /**
     * Returns the raw JSON value of [c4colon].
     *
     * Unlike [c4colon], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4colon(): JsonField<Int> = body._c4colon()

    /**
     * Returns the raw JSON value of [c4def].
     *
     * Unlike [c4def], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4def(): JsonField<String> = body._c4def()

    /**
     * Returns the raw JSON value of [c4egress].
     *
     * Unlike [c4egress], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4egress(): JsonField<Int> = body._c4egress()

    /**
     * Returns the raw JSON value of [c4mod].
     *
     * Unlike [c4mod], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4mod(): JsonField<Int> = body._c4mod()

    /**
     * Returns the raw JSON value of [c4numberofstores].
     *
     * Unlike [c4numberofstores], this method doesn't throw if the JSON field has an unexpected
     * type.
     */
    fun _c4numberofstores(): JsonField<Int> = body._c4numberofstores()

    /**
     * Returns the raw JSON value of [c4runin].
     *
     * Unlike [c4runin], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4runin(): JsonField<Int> = body._c4runin()

    /**
     * Returns the raw JSON value of [c4tgt].
     *
     * Unlike [c4tgt], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4tgt(): JsonField<String> = body._c4tgt()

    /**
     * Returns the raw JSON value of [c4timediscrete].
     *
     * Unlike [c4timediscrete], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4timediscrete(): JsonField<String> = body._c4timediscrete()

    /**
     * Returns the raw JSON value of [c4tm].
     *
     * Unlike [c4tm], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4tm(): JsonField<Int> = body._c4tm()

    /**
     * Returns the raw JSON value of [c4typeofstores].
     *
     * Unlike [c4typeofstores], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c4typeofstores(): JsonField<Int> = body._c4typeofstores()

    /**
     * Returns the raw JSON value of [c5colon].
     *
     * Unlike [c5colon], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c5colon(): JsonField<Int> = body._c5colon()

    /**
     * Returns the raw JSON value of [c5elevationlsbs].
     *
     * Unlike [c5elevationlsbs], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c5elevationlsbs(): JsonField<Int> = body._c5elevationlsbs()

    /**
     * Returns the raw JSON value of [c5haeadj].
     *
     * Unlike [c5haeadj], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c5haeadj(): JsonField<Int> = body._c5haeadj()

    /**
     * Returns the raw JSON value of [c5latlsb].
     *
     * Unlike [c5latlsb], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c5latlsb(): JsonField<Int> = body._c5latlsb()

    /**
     * Returns the raw JSON value of [c5lonlsb].
     *
     * Unlike [c5lonlsb], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c5lonlsb(): JsonField<Int> = body._c5lonlsb()

    /**
     * Returns the raw JSON value of [c5tgtbrng].
     *
     * Unlike [c5tgtbrng], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c5tgtbrng(): JsonField<Int> = body._c5tgtbrng()

    /**
     * Returns the raw JSON value of [c5tw].
     *
     * Unlike [c5tw], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c5tw(): JsonField<Int> = body._c5tw()

    /**
     * Returns the raw JSON value of [c6dspc].
     *
     * Unlike [c6dspc], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c6dspc(): JsonField<String> = body._c6dspc()

    /**
     * Returns the raw JSON value of [c6dspct].
     *
     * Unlike [c6dspct], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c6dspct(): JsonField<String> = body._c6dspct()

    /**
     * Returns the raw JSON value of [c6fplpm].
     *
     * Unlike [c6fplpm], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c6fplpm(): JsonField<String> = body._c6fplpm()

    /**
     * Returns the raw JSON value of [c6intel].
     *
     * Unlike [c6intel], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c6intel(): JsonField<Int> = body._c6intel()

    /**
     * Returns the raw JSON value of [c6laser].
     *
     * Unlike [c6laser], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c6laser(): JsonField<Int> = body._c6laser()

    /**
     * Returns the raw JSON value of [c6longpm].
     *
     * Unlike [c6longpm], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c6longpm(): JsonField<String> = body._c6longpm()

    /**
     * Returns the raw JSON value of [c6tnr3].
     *
     * Unlike [c6tnr3], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c6tnr3(): JsonField<Int> = body._c6tnr3()

    /**
     * Returns the raw JSON value of [c7elang2].
     *
     * Unlike [c7elang2], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c7elang2(): JsonField<Double> = body._c7elang2()

    /**
     * Returns the raw JSON value of [c7in3p].
     *
     * Unlike [c7in3p], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c7in3p(): JsonField<Int> = body._c7in3p()

    /**
     * Returns the raw JSON value of [c7tnor].
     *
     * Unlike [c7tnor], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _c7tnor(): JsonField<String> = body._c7tnor()

    /**
     * Returns the raw JSON value of [createdAt].
     *
     * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _createdAt(): JsonField<OffsetDateTime> = body._createdAt()

    /**
     * Returns the raw JSON value of [createdBy].
     *
     * Unlike [createdBy], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _createdBy(): JsonField<String> = body._createdBy()

    /**
     * Returns the raw JSON value of [env].
     *
     * Unlike [env], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _env(): JsonField<String> = body._env()

    /**
     * Returns the raw JSON value of [index].
     *
     * Unlike [index], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _index(): JsonField<Int> = body._index()

    /**
     * Returns the raw JSON value of [lat].
     *
     * Unlike [lat], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _lat(): JsonField<Double> = body._lat()

    /**
     * Returns the raw JSON value of [lon].
     *
     * Unlike [lon], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _lon(): JsonField<Double> = body._lon()

    /**
     * Returns the raw JSON value of [orginx].
     *
     * Unlike [orginx], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _orginx(): JsonField<String> = body._orginx()

    /**
     * Returns the raw JSON value of [origin].
     *
     * Unlike [origin], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _origin(): JsonField<String> = body._origin()

    /**
     * Returns the raw JSON value of [origNetwork].
     *
     * Unlike [origNetwork], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _origNetwork(): JsonField<String> = body._origNetwork()

    /**
     * Returns the raw JSON value of [rc].
     *
     * Unlike [rc], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _rc(): JsonField<String> = body._rc()

    /**
     * Returns the raw JSON value of [rr].
     *
     * Unlike [rr], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _rr(): JsonField<Int> = body._rr()

    /**
     * Returns the raw JSON value of [sz].
     *
     * Unlike [sz], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _sz(): JsonField<String> = body._sz()

    /**
     * Returns the raw JSON value of [tno].
     *
     * Unlike [tno], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _tno(): JsonField<String> = body._tno()

    /**
     * Returns the raw JSON value of [trkId].
     *
     * Unlike [trkId], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _trkId(): JsonField<String> = body._trkId()

    /**
     * Returns the raw JSON value of [twenv].
     *
     * Unlike [twenv], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _twenv(): JsonField<String> = body._twenv()

    fun _additionalBodyProperties(): Map<String, JsonValue> = body._additionalProperties()

    /** Additional headers to send with the request. */
    fun _additionalHeaders(): Headers = additionalHeaders

    /** Additional query param to send with the request. */
    fun _additionalQueryParams(): QueryParams = additionalQueryParams

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of
         * [MissionAssignmentUpdateParams].
         *
         * The following fields are required:
         * ```java
         * .classificationMarking()
         * .dataMode()
         * .mad()
         * .source()
         * .ts()
         * ```
         */
        @JvmStatic fun builder() = Builder()
    }

    /** A builder for [MissionAssignmentUpdateParams]. */
    class Builder internal constructor() {

        private var pathId: String? = null
        private var body: Body.Builder = Body.builder()
        private var additionalHeaders: Headers.Builder = Headers.builder()
        private var additionalQueryParams: QueryParams.Builder = QueryParams.builder()

        @JvmSynthetic
        internal fun from(missionAssignmentUpdateParams: MissionAssignmentUpdateParams) = apply {
            pathId = missionAssignmentUpdateParams.pathId
            body = missionAssignmentUpdateParams.body.toBuilder()
            additionalHeaders = missionAssignmentUpdateParams.additionalHeaders.toBuilder()
            additionalQueryParams = missionAssignmentUpdateParams.additionalQueryParams.toBuilder()
        }

        fun pathId(pathId: String?) = apply { this.pathId = pathId }

        /** Alias for calling [Builder.pathId] with `pathId.orElse(null)`. */
        fun pathId(pathId: Optional<String>) = pathId(pathId.getOrNull())

        /**
         * Sets the entire request body.
         *
         * This is generally only useful if you are already constructing the body separately.
         * Otherwise, it's more convenient to use the top-level setters instead:
         * - [classificationMarking]
         * - [dataMode]
         * - [mad]
         * - [source]
         * - [ts]
         * - etc.
         */
        fun body(body: Body) = apply { this.body = body.toBuilder() }

        /** Classification marking of the data in IC/CAPCO Portion-marked format. */
        fun classificationMarking(classificationMarking: String) = apply {
            body.classificationMarking(classificationMarking)
        }

        /**
         * Sets [Builder.classificationMarking] to an arbitrary JSON value.
         *
         * You should usually call [Builder.classificationMarking] with a well-typed [String] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun classificationMarking(classificationMarking: JsonField<String>) = apply {
            body.classificationMarking(classificationMarking)
        }

        /**
         * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
         *
         * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include
         * both real and simulated data.
         *
         * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and
         * analysis.
         *
         * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
         *
         * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
         * requirements, and for validating technical, functional, and performance characteristics.
         */
        fun dataMode(dataMode: DataMode) = apply { body.dataMode(dataMode) }

        /**
         * Sets [Builder.dataMode] to an arbitrary JSON value.
         *
         * You should usually call [Builder.dataMode] with a well-typed [DataMode] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun dataMode(dataMode: JsonField<DataMode>) = apply { body.dataMode(dataMode) }

        /** The mission assignment discrete value. */
        fun mad(mad: String) = apply { body.mad(mad) }

        /**
         * Sets [Builder.mad] to an arbitrary JSON value.
         *
         * You should usually call [Builder.mad] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun mad(mad: JsonField<String>) = apply { body.mad(mad) }

        /** Source of the data. */
        fun source(source: String) = apply { body.source(source) }

        /**
         * Sets [Builder.source] to an arbitrary JSON value.
         *
         * You should usually call [Builder.source] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun source(source: JsonField<String>) = apply { body.source(source) }

        /** The timestamp of the mission data, in ISO 8601 UTC format. */
        fun ts(ts: OffsetDateTime) = apply { body.ts(ts) }

        /**
         * Sets [Builder.ts] to an arbitrary JSON value.
         *
         * You should usually call [Builder.ts] with a well-typed [OffsetDateTime] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun ts(ts: JsonField<OffsetDateTime>) = apply { body.ts(ts) }

        /** Unique identifier of the record, auto-generated by the system. */
        fun bodyId(bodyId: String) = apply { body.bodyId(bodyId) }

        /**
         * Sets [Builder.bodyId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.bodyId] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun bodyId(bodyId: JsonField<String>) = apply { body.bodyId(bodyId) }

        /** TARGET POSITION CONTINUATION WORD - number of associated dmpis. */
        fun c1associateddmpis(c1associateddmpis: Int) = apply {
            body.c1associateddmpis(c1associateddmpis)
        }

        /**
         * Sets [Builder.c1associateddmpis] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c1associateddmpis] with a well-typed [Int] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun c1associateddmpis(c1associateddmpis: JsonField<Int>) = apply {
            body.c1associateddmpis(c1associateddmpis)
        }

        /** TARGET DATA CONTINUATION WORD - air specific type, see TABLE B-21. */
        fun c2air(c2air: String) = apply { body.c2air(c2air) }

        /**
         * Sets [Builder.c2air] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2air] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c2air(c2air: JsonField<String>) = apply { body.c2air(c2air) }

        /** TARGET DATA CONTINUATION WORD - altitude, 100 FT, 2047=NS. */
        fun c2alt(c2alt: Int) = apply { body.c2alt(c2alt) }

        /**
         * Sets [Builder.c2alt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2alt] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c2alt(c2alt: JsonField<Int>) = apply { body.c2alt(c2alt) }

        /** TARGET DATA CONTINUATION WORD - course in increments of 1 degree. */
        fun c2crs(c2crs: Int) = apply { body.c2crs(c2crs) }

        /**
         * Sets [Builder.c2crs] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2crs] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c2crs(c2crs: JsonField<Int>) = apply { body.c2crs(c2crs) }

        /** TARGET DATA CONTINUATION WORD - exercise indicator. */
        fun c2exerciseindicator(c2exerciseindicator: String) = apply {
            body.c2exerciseindicator(c2exerciseindicator)
        }

        /**
         * Sets [Builder.c2exerciseindicator] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2exerciseindicator] with a well-typed [String] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun c2exerciseindicator(c2exerciseindicator: JsonField<String>) = apply {
            body.c2exerciseindicator(c2exerciseindicator)
        }

        /** TARGET DATA CONTINUATION WORD - method of fire. */
        fun c2exercisemof(c2exercisemof: String) = apply { body.c2exercisemof(c2exercisemof) }

        /**
         * Sets [Builder.c2exercisemof] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2exercisemof] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun c2exercisemof(c2exercisemof: JsonField<String>) = apply {
            body.c2exercisemof(c2exercisemof)
        }

        /** TARGET DATA CONTINUATION WORD - identity. */
        fun c2id(c2id: String) = apply { body.c2id(c2id) }

        /**
         * Sets [Builder.c2id] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2id] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c2id(c2id: JsonField<String>) = apply { body.c2id(c2id) }

        /** TARGET DATA CONTINUATION WORD - identity amplifying descriptor. */
        fun c2idamplifyingdescriptor(c2idamplifyingdescriptor: String) = apply {
            body.c2idamplifyingdescriptor(c2idamplifyingdescriptor)
        }

        /**
         * Sets [Builder.c2idamplifyingdescriptor] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2idamplifyingdescriptor] with a well-typed [String]
         * value instead. This method is primarily for setting the field to an undocumented or not
         * yet supported value.
         */
        fun c2idamplifyingdescriptor(c2idamplifyingdescriptor: JsonField<String>) = apply {
            body.c2idamplifyingdescriptor(c2idamplifyingdescriptor)
        }

        /** TARGET DATA CONTINUATION WORD - land specific type, see TABLE B-21. */
        fun c2lnd(c2lnd: String) = apply { body.c2lnd(c2lnd) }

        /**
         * Sets [Builder.c2lnd] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2lnd] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c2lnd(c2lnd: JsonField<String>) = apply { body.c2lnd(c2lnd) }

        /** TARGET DATA CONTINUATION WORD - space specific type, see TABLE B-39. */
        fun c2spc(c2spc: String) = apply { body.c2spc(c2spc) }

        /**
         * Sets [Builder.c2spc] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2spc] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c2spc(c2spc: JsonField<String>) = apply { body.c2spc(c2spc) }

        /** TARGET DATA CONTINUATION WORD - speed in 2 DM/HR, 2047=NS. */
        fun c2spd(c2spd: Int) = apply { body.c2spd(c2spd) }

        /**
         * Sets [Builder.c2spd] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2spd] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c2spd(c2spd: JsonField<Int>) = apply { body.c2spd(c2spd) }

        /** TARGET DATA CONTINUATION WORD - special interest indicator. */
        fun c2specialinterestindicator(c2specialinterestindicator: String) = apply {
            body.c2specialinterestindicator(c2specialinterestindicator)
        }

        /**
         * Sets [Builder.c2specialinterestindicator] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2specialinterestindicator] with a well-typed [String]
         * value instead. This method is primarily for setting the field to an undocumented or not
         * yet supported value.
         */
        fun c2specialinterestindicator(c2specialinterestindicator: JsonField<String>) = apply {
            body.c2specialinterestindicator(c2specialinterestindicator)
        }

        /** TARGET DATA CONTINUATION WORD - surface specific type, see TABLE B-21. */
        fun c2sur(c2sur: String) = apply { body.c2sur(c2sur) }

        /**
         * Sets [Builder.c2sur] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c2sur] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c2sur(c2sur: JsonField<String>) = apply { body.c2sur(c2sur) }

        /** POINT LOCATION CONTINUATION WORD - elevation, 25 FT, 1023=NS. */
        fun c3elv(c3elv: Double) = apply { body.c3elv(c3elv) }

        /**
         * Sets [Builder.c3elv] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c3elv] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c3elv(c3elv: JsonField<Double>) = apply { body.c3elv(c3elv) }

        /** POINT LOCATION CONTINUATION WORD - latitude, 0.0013 MINUTE. */
        fun c3lat(c3lat: Double) = apply { body.c3lat(c3lat) }

        /**
         * Sets [Builder.c3lat] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c3lat] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c3lat(c3lat: JsonField<Double>) = apply { body.c3lat(c3lat) }

        /** POINT LOCATION CONTINUATION WORD - longitude, 0.0013 MINUTE. */
        fun c3lon(c3lon: Double) = apply { body.c3lon(c3lon) }

        /**
         * Sets [Builder.c3lon] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c3lon] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c3lon(c3lon: JsonField<Double>) = apply { body.c3lon(c3lon) }

        /** TARGET DATA CONTINUATION WORD - point type 1. */
        fun c3ptl(c3ptl: String) = apply { body.c3ptl(c3ptl) }

        /**
         * Sets [Builder.c3ptl] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c3ptl] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c3ptl(c3ptl: JsonField<String>) = apply { body.c3ptl(c3ptl) }

        /** TARGET DATA CONTINUATION WORD - point number. */
        fun c3ptnum(c3ptnum: String) = apply { body.c3ptnum(c3ptnum) }

        /**
         * Sets [Builder.c3ptnum] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c3ptnum] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c3ptnum(c3ptnum: JsonField<String>) = apply { body.c3ptnum(c3ptnum) }

        /** SURFACE ATTACK CONTINUATION WORD - minute. */
        fun c4colon(c4colon: Int) = apply { body.c4colon(c4colon) }

        /**
         * Sets [Builder.c4colon] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4colon] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c4colon(c4colon: JsonField<Int>) = apply { body.c4colon(c4colon) }

        /** SURFACE ATTACK CONTINUATION WORD - target defenses. */
        fun c4def(c4def: String) = apply { body.c4def(c4def) }

        /**
         * Sets [Builder.c4def] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4def] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c4def(c4def: JsonField<String>) = apply { body.c4def(c4def) }

        /** SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511. */
        fun c4egress(c4egress: Int) = apply { body.c4egress(c4egress) }

        /**
         * Sets [Builder.c4egress] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4egress] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c4egress(c4egress: JsonField<Int>) = apply { body.c4egress(c4egress) }

        /** SURFACE ATTACK CONTINUATION WORD - mode of delivery. */
        fun c4mod(c4mod: Int) = apply { body.c4mod(c4mod) }

        /**
         * Sets [Builder.c4mod] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4mod] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c4mod(c4mod: JsonField<Int>) = apply { body.c4mod(c4mod) }

        /** SURFACE ATTACK CONTINUATION WORD - number of stores, NS=63. */
        fun c4numberofstores(c4numberofstores: Int) = apply {
            body.c4numberofstores(c4numberofstores)
        }

        /**
         * Sets [Builder.c4numberofstores] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4numberofstores] with a well-typed [Int] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun c4numberofstores(c4numberofstores: JsonField<Int>) = apply {
            body.c4numberofstores(c4numberofstores)
        }

        /** SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511. */
        fun c4runin(c4runin: Int) = apply { body.c4runin(c4runin) }

        /**
         * Sets [Builder.c4runin] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4runin] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c4runin(c4runin: JsonField<Int>) = apply { body.c4runin(c4runin) }

        /** SURFACE ATTACK CONTINUATION WORD - target type - see TABLE B-32. */
        fun c4tgt(c4tgt: String) = apply { body.c4tgt(c4tgt) }

        /**
         * Sets [Builder.c4tgt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4tgt] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c4tgt(c4tgt: JsonField<String>) = apply { body.c4tgt(c4tgt) }

        /** SURFACE ATTACK CONTINUATION WORD - time discrete. */
        fun c4timediscrete(c4timediscrete: String) = apply { body.c4timediscrete(c4timediscrete) }

        /**
         * Sets [Builder.c4timediscrete] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4timediscrete] with a well-typed [String] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun c4timediscrete(c4timediscrete: JsonField<String>) = apply {
            body.c4timediscrete(c4timediscrete)
        }

        /** SURFACE ATTACK CONTINUATION WORD - hour. */
        fun c4tm(c4tm: Int) = apply { body.c4tm(c4tm) }

        /**
         * Sets [Builder.c4tm] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4tm] with a well-typed [Int] value instead. This method
         * is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c4tm(c4tm: JsonField<Int>) = apply { body.c4tm(c4tm) }

        /** SURFACE ATTACK CONTINUATION WORD - type of stores. */
        fun c4typeofstores(c4typeofstores: Int) = apply { body.c4typeofstores(c4typeofstores) }

        /**
         * Sets [Builder.c4typeofstores] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c4typeofstores] with a well-typed [Int] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun c4typeofstores(c4typeofstores: JsonField<Int>) = apply {
            body.c4typeofstores(c4typeofstores)
        }

        /** SURFACE ATTACK CONTINUATION WORD - seconds in increments of 1 sec. */
        fun c5colon(c5colon: Int) = apply { body.c5colon(c5colon) }

        /**
         * Sets [Builder.c5colon] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c5colon] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c5colon(c5colon: JsonField<Int>) = apply { body.c5colon(c5colon) }

        /** CONTINUATION WORD - used with c3_elv to double precision to approx 3 ft. */
        fun c5elevationlsbs(c5elevationlsbs: Int) = apply { body.c5elevationlsbs(c5elevationlsbs) }

        /**
         * Sets [Builder.c5elevationlsbs] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c5elevationlsbs] with a well-typed [Int] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun c5elevationlsbs(c5elevationlsbs: JsonField<Int>) = apply {
            body.c5elevationlsbs(c5elevationlsbs)
        }

        /** CONTINUATION WORD - hae adjustment, measured in 3.125 FT. */
        fun c5haeadj(c5haeadj: Int) = apply { body.c5haeadj(c5haeadj) }

        /**
         * Sets [Builder.c5haeadj] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c5haeadj] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c5haeadj(c5haeadj: JsonField<Int>) = apply { body.c5haeadj(c5haeadj) }

        /** CONTINUATION WORD - used with c3_lat to double precision to approx 4 ft. */
        fun c5latlsb(c5latlsb: Int) = apply { body.c5latlsb(c5latlsb) }

        /**
         * Sets [Builder.c5latlsb] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c5latlsb] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c5latlsb(c5latlsb: JsonField<Int>) = apply { body.c5latlsb(c5latlsb) }

        /** CONTINUATION WORD - used with c3_lon to double precision to approx 4 ft. */
        fun c5lonlsb(c5lonlsb: Int) = apply { body.c5lonlsb(c5lonlsb) }

        /**
         * Sets [Builder.c5lonlsb] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c5lonlsb] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c5lonlsb(c5lonlsb: JsonField<Int>) = apply { body.c5lonlsb(c5lonlsb) }

        /** CONTINUATION WORD - target bearing. */
        fun c5tgtbrng(c5tgtbrng: Int) = apply { body.c5tgtbrng(c5tgtbrng) }

        /**
         * Sets [Builder.c5tgtbrng] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c5tgtbrng] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c5tgtbrng(c5tgtbrng: JsonField<Int>) = apply { body.c5tgtbrng(c5tgtbrng) }

        /** CONTINUATION WORD - time window. */
        fun c5tw(c5tw: Int) = apply { body.c5tw(c5tw) }

        /**
         * Sets [Builder.c5tw] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c5tw] with a well-typed [Int] value instead. This method
         * is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c5tw(c5tw: JsonField<Int>) = apply { body.c5tw(c5tw) }

        /** TARGETING CONTINUATION WORD - designator/seeker pulse code. */
        fun c6dspc(c6dspc: String) = apply { body.c6dspc(c6dspc) }

        /**
         * Sets [Builder.c6dspc] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c6dspc] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c6dspc(c6dspc: JsonField<String>) = apply { body.c6dspc(c6dspc) }

        /** TARGETING CONTINUATION WORD - designator/seeker pulse code type. */
        fun c6dspct(c6dspct: String) = apply { body.c6dspct(c6dspct) }

        /**
         * Sets [Builder.c6dspct] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c6dspct] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c6dspct(c6dspct: JsonField<String>) = apply { body.c6dspct(c6dspct) }

        /** TARGETING CONTINUATION WORD - first pulse/last pulse mode. */
        fun c6fplpm(c6fplpm: String) = apply { body.c6fplpm(c6fplpm) }

        /**
         * Sets [Builder.c6fplpm] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c6fplpm] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c6fplpm(c6fplpm: JsonField<String>) = apply { body.c6fplpm(c6fplpm) }

        /** TARGETING CONTINUATION WORD - index number, related, 0=NS. */
        fun c6intel(c6intel: Int) = apply { body.c6intel(c6intel) }

        /**
         * Sets [Builder.c6intel] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c6intel] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c6intel(c6intel: JsonField<Int>) = apply { body.c6intel(c6intel) }

        /** TARGETING CONTINUATION WORD - laser illuminator code. */
        fun c6laser(c6laser: Int) = apply { body.c6laser(c6laser) }

        /**
         * Sets [Builder.c6laser] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c6laser] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c6laser(c6laser: JsonField<Int>) = apply { body.c6laser(c6laser) }

        /** TARGETING CONTINUATION WORD - long pulse mode. */
        fun c6longpm(c6longpm: String) = apply { body.c6longpm(c6longpm) }

        /**
         * Sets [Builder.c6longpm] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c6longpm] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c6longpm(c6longpm: JsonField<String>) = apply { body.c6longpm(c6longpm) }

        /** TARGETING CONTINUATION WORD - track number, related to 3. */
        fun c6tnr3(c6tnr3: Int) = apply { body.c6tnr3(c6tnr3) }

        /**
         * Sets [Builder.c6tnr3] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c6tnr3] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c6tnr3(c6tnr3: JsonField<Int>) = apply { body.c6tnr3(c6tnr3) }

        /** THIRD PARTY CONTINUATION WORD - elevation angle, 2. */
        fun c7elang2(c7elang2: Double) = apply { body.c7elang2(c7elang2) }

        /**
         * Sets [Builder.c7elang2] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c7elang2] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c7elang2(c7elang2: JsonField<Double>) = apply { body.c7elang2(c7elang2) }

        /** THIRD PARTY CONTINUATION WORD - index number, third party. */
        fun c7in3p(c7in3p: Int) = apply { body.c7in3p(c7in3p) }

        /**
         * Sets [Builder.c7in3p] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c7in3p] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c7in3p(c7in3p: JsonField<Int>) = apply { body.c7in3p(c7in3p) }

        /** THIRD PARTY CONTINUATION WORD - track number, index originator. */
        fun c7tnor(c7tnor: String) = apply { body.c7tnor(c7tnor) }

        /**
         * Sets [Builder.c7tnor] to an arbitrary JSON value.
         *
         * You should usually call [Builder.c7tnor] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun c7tnor(c7tnor: JsonField<String>) = apply { body.c7tnor(c7tnor) }

        /** Time the row was created in the database, auto-populated by the system. */
        fun createdAt(createdAt: OffsetDateTime) = apply { body.createdAt(createdAt) }

        /**
         * Sets [Builder.createdAt] to an arbitrary JSON value.
         *
         * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
         * instead. This method is primarily for setting the field to an undocumented or not yet
         * supported value.
         */
        fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply { body.createdAt(createdAt) }

        /** Application user who created the row in the database, auto-populated by the system. */
        fun createdBy(createdBy: String) = apply { body.createdBy(createdBy) }

        /**
         * Sets [Builder.createdBy] to an arbitrary JSON value.
         *
         * You should usually call [Builder.createdBy] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun createdBy(createdBy: JsonField<String>) = apply { body.createdBy(createdBy) }

        /** Environment. */
        fun env(env: String) = apply { body.env(env) }

        /**
         * Sets [Builder.env] to an arbitrary JSON value.
         *
         * You should usually call [Builder.env] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun env(env: JsonField<String>) = apply { body.env(env) }

        /** Index number. */
        fun index(index: Int) = apply { body.index(index) }

        /**
         * Sets [Builder.index] to an arbitrary JSON value.
         *
         * You should usually call [Builder.index] with a well-typed [Int] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun index(index: JsonField<Int>) = apply { body.index(index) }

        /** WGS84 latitude, in degrees. -90 to 90 degrees (negative values south of equator). */
        fun lat(lat: Double) = apply { body.lat(lat) }

        /**
         * Sets [Builder.lat] to an arbitrary JSON value.
         *
         * You should usually call [Builder.lat] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun lat(lat: JsonField<Double>) = apply { body.lat(lat) }

        /**
         * WGS84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime
         * Meridian).
         */
        fun lon(lon: Double) = apply { body.lon(lon) }

        /**
         * Sets [Builder.lon] to an arbitrary JSON value.
         *
         * You should usually call [Builder.lon] with a well-typed [Double] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun lon(lon: JsonField<Double>) = apply { body.lon(lon) }

        /** Origin of index number. */
        fun orginx(orginx: String) = apply { body.orginx(orginx) }

        /**
         * Sets [Builder.orginx] to an arbitrary JSON value.
         *
         * You should usually call [Builder.orginx] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun orginx(orginx: JsonField<String>) = apply { body.orginx(orginx) }

        /**
         * Originating system or organization which produced the data, if different from the source.
         * The origin may be different than the source if the source was a mediating system which
         * forwarded the data on behalf of the origin system. If null, the source may be assumed to
         * be the origin.
         */
        fun origin(origin: String) = apply { body.origin(origin) }

        /**
         * Sets [Builder.origin] to an arbitrary JSON value.
         *
         * You should usually call [Builder.origin] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun origin(origin: JsonField<String>) = apply { body.origin(origin) }

        /**
         * The originating source network on which this record was created, auto-populated by the
         * system.
         */
        fun origNetwork(origNetwork: String) = apply { body.origNetwork(origNetwork) }

        /**
         * Sets [Builder.origNetwork] to an arbitrary JSON value.
         *
         * You should usually call [Builder.origNetwork] with a well-typed [String] value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun origNetwork(origNetwork: JsonField<String>) = apply { body.origNetwork(origNetwork) }

        /** Receipt/Compliance, values from TABLE B-9. */
        fun rc(rc: String) = apply { body.rc(rc) }

        /**
         * Sets [Builder.rc] to an arbitrary JSON value.
         *
         * You should usually call [Builder.rc] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun rc(rc: JsonField<String>) = apply { body.rc(rc) }

        /** Recurrence rate, receipt/compliance. */
        fun rr(rr: Int) = apply { body.rr(rr) }

        /**
         * Sets [Builder.rr] to an arbitrary JSON value.
         *
         * You should usually call [Builder.rr] with a well-typed [Int] value instead. This method
         * is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun rr(rr: JsonField<Int>) = apply { body.rr(rr) }

        /** Strength. */
        fun sz(sz: String) = apply { body.sz(sz) }

        /**
         * Sets [Builder.sz] to an arbitrary JSON value.
         *
         * You should usually call [Builder.sz] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun sz(sz: JsonField<String>) = apply { body.sz(sz) }

        /** Track number objective. */
        fun tno(tno: String) = apply { body.tno(tno) }

        /**
         * Sets [Builder.tno] to an arbitrary JSON value.
         *
         * You should usually call [Builder.tno] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun tno(tno: JsonField<String>) = apply { body.tno(tno) }

        /** The track ID that the status is referencing, addressee. */
        fun trkId(trkId: String) = apply { body.trkId(trkId) }

        /**
         * Sets [Builder.trkId] to an arbitrary JSON value.
         *
         * You should usually call [Builder.trkId] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun trkId(trkId: JsonField<String>) = apply { body.trkId(trkId) }

        /** Threat warning environment. */
        fun twenv(twenv: String) = apply { body.twenv(twenv) }

        /**
         * Sets [Builder.twenv] to an arbitrary JSON value.
         *
         * You should usually call [Builder.twenv] with a well-typed [String] value instead. This
         * method is primarily for setting the field to an undocumented or not yet supported value.
         */
        fun twenv(twenv: JsonField<String>) = apply { body.twenv(twenv) }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            body.additionalProperties(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            body.putAdditionalProperty(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                body.putAllAdditionalProperties(additionalBodyProperties)
            }

        fun removeAdditionalBodyProperty(key: String) = apply { body.removeAdditionalProperty(key) }

        fun removeAllAdditionalBodyProperties(keys: Set<String>) = apply {
            body.removeAllAdditionalProperties(keys)
        }

        fun additionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun putAdditionalHeader(name: String, value: String) = apply {
            additionalHeaders.put(name, value)
        }

        fun putAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.put(name, values)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun replaceAdditionalHeaders(name: String, value: String) = apply {
            additionalHeaders.replace(name, value)
        }

        fun replaceAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.replace(name, values)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun removeAdditionalHeaders(name: String) = apply { additionalHeaders.remove(name) }

        fun removeAllAdditionalHeaders(names: Set<String>) = apply {
            additionalHeaders.removeAll(names)
        }

        fun additionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun putAdditionalQueryParam(key: String, value: String) = apply {
            additionalQueryParams.put(key, value)
        }

        fun putAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.put(key, values)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.putAll(additionalQueryParams)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.putAll(additionalQueryParams)
            }

        fun replaceAdditionalQueryParams(key: String, value: String) = apply {
            additionalQueryParams.replace(key, value)
        }

        fun replaceAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.replace(key, values)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.replaceAll(additionalQueryParams)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.replaceAll(additionalQueryParams)
            }

        fun removeAdditionalQueryParams(key: String) = apply { additionalQueryParams.remove(key) }

        fun removeAllAdditionalQueryParams(keys: Set<String>) = apply {
            additionalQueryParams.removeAll(keys)
        }

        /**
         * Returns an immutable instance of [MissionAssignmentUpdateParams].
         *
         * Further updates to this [Builder] will not mutate the returned instance.
         *
         * The following fields are required:
         * ```java
         * .classificationMarking()
         * .dataMode()
         * .mad()
         * .source()
         * .ts()
         * ```
         *
         * @throws IllegalStateException if any required field is unset.
         */
        fun build(): MissionAssignmentUpdateParams =
            MissionAssignmentUpdateParams(
                pathId,
                body.build(),
                additionalHeaders.build(),
                additionalQueryParams.build(),
            )
    }

    fun _body(): Body = body

    fun _pathParam(index: Int): String =
        when (index) {
            0 -> pathId ?: ""
            else -> ""
        }

    override fun _headers(): Headers = additionalHeaders

    override fun _queryParams(): QueryParams = additionalQueryParams

    /** Platform mission assignment data. */
    class Body
    private constructor(
        private val classificationMarking: JsonField<String>,
        private val dataMode: JsonField<DataMode>,
        private val mad: JsonField<String>,
        private val source: JsonField<String>,
        private val ts: JsonField<OffsetDateTime>,
        private val bodyId: JsonField<String>,
        private val c1associateddmpis: JsonField<Int>,
        private val c2air: JsonField<String>,
        private val c2alt: JsonField<Int>,
        private val c2crs: JsonField<Int>,
        private val c2exerciseindicator: JsonField<String>,
        private val c2exercisemof: JsonField<String>,
        private val c2id: JsonField<String>,
        private val c2idamplifyingdescriptor: JsonField<String>,
        private val c2lnd: JsonField<String>,
        private val c2spc: JsonField<String>,
        private val c2spd: JsonField<Int>,
        private val c2specialinterestindicator: JsonField<String>,
        private val c2sur: JsonField<String>,
        private val c3elv: JsonField<Double>,
        private val c3lat: JsonField<Double>,
        private val c3lon: JsonField<Double>,
        private val c3ptl: JsonField<String>,
        private val c3ptnum: JsonField<String>,
        private val c4colon: JsonField<Int>,
        private val c4def: JsonField<String>,
        private val c4egress: JsonField<Int>,
        private val c4mod: JsonField<Int>,
        private val c4numberofstores: JsonField<Int>,
        private val c4runin: JsonField<Int>,
        private val c4tgt: JsonField<String>,
        private val c4timediscrete: JsonField<String>,
        private val c4tm: JsonField<Int>,
        private val c4typeofstores: JsonField<Int>,
        private val c5colon: JsonField<Int>,
        private val c5elevationlsbs: JsonField<Int>,
        private val c5haeadj: JsonField<Int>,
        private val c5latlsb: JsonField<Int>,
        private val c5lonlsb: JsonField<Int>,
        private val c5tgtbrng: JsonField<Int>,
        private val c5tw: JsonField<Int>,
        private val c6dspc: JsonField<String>,
        private val c6dspct: JsonField<String>,
        private val c6fplpm: JsonField<String>,
        private val c6intel: JsonField<Int>,
        private val c6laser: JsonField<Int>,
        private val c6longpm: JsonField<String>,
        private val c6tnr3: JsonField<Int>,
        private val c7elang2: JsonField<Double>,
        private val c7in3p: JsonField<Int>,
        private val c7tnor: JsonField<String>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val createdBy: JsonField<String>,
        private val env: JsonField<String>,
        private val index: JsonField<Int>,
        private val lat: JsonField<Double>,
        private val lon: JsonField<Double>,
        private val orginx: JsonField<String>,
        private val origin: JsonField<String>,
        private val origNetwork: JsonField<String>,
        private val rc: JsonField<String>,
        private val rr: JsonField<Int>,
        private val sz: JsonField<String>,
        private val tno: JsonField<String>,
        private val trkId: JsonField<String>,
        private val twenv: JsonField<String>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("classificationMarking")
            @ExcludeMissing
            classificationMarking: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dataMode")
            @ExcludeMissing
            dataMode: JsonField<DataMode> = JsonMissing.of(),
            @JsonProperty("mad") @ExcludeMissing mad: JsonField<String> = JsonMissing.of(),
            @JsonProperty("source") @ExcludeMissing source: JsonField<String> = JsonMissing.of(),
            @JsonProperty("ts") @ExcludeMissing ts: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("id") @ExcludeMissing bodyId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c1associateddmpis")
            @ExcludeMissing
            c1associateddmpis: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c2air") @ExcludeMissing c2air: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c2alt") @ExcludeMissing c2alt: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c2crs") @ExcludeMissing c2crs: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c2exerciseindicator")
            @ExcludeMissing
            c2exerciseindicator: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c2exercisemof")
            @ExcludeMissing
            c2exercisemof: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c2id") @ExcludeMissing c2id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c2idamplifyingdescriptor")
            @ExcludeMissing
            c2idamplifyingdescriptor: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c2lnd") @ExcludeMissing c2lnd: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c2spc") @ExcludeMissing c2spc: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c2spd") @ExcludeMissing c2spd: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c2specialinterestindicator")
            @ExcludeMissing
            c2specialinterestindicator: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c2sur") @ExcludeMissing c2sur: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c3elv") @ExcludeMissing c3elv: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("c3lat") @ExcludeMissing c3lat: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("c3lon") @ExcludeMissing c3lon: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("c3ptl") @ExcludeMissing c3ptl: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c3ptnum") @ExcludeMissing c3ptnum: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c4colon") @ExcludeMissing c4colon: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c4def") @ExcludeMissing c4def: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c4egress") @ExcludeMissing c4egress: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c4mod") @ExcludeMissing c4mod: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c4numberofstores")
            @ExcludeMissing
            c4numberofstores: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c4runin") @ExcludeMissing c4runin: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c4tgt") @ExcludeMissing c4tgt: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c4timediscrete")
            @ExcludeMissing
            c4timediscrete: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c4tm") @ExcludeMissing c4tm: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c4typeofstores")
            @ExcludeMissing
            c4typeofstores: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c5colon") @ExcludeMissing c5colon: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c5elevationlsbs")
            @ExcludeMissing
            c5elevationlsbs: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c5haeadj") @ExcludeMissing c5haeadj: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c5latlsb") @ExcludeMissing c5latlsb: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c5lonlsb") @ExcludeMissing c5lonlsb: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c5tgtbrng") @ExcludeMissing c5tgtbrng: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c5tw") @ExcludeMissing c5tw: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c6dspc") @ExcludeMissing c6dspc: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c6dspct") @ExcludeMissing c6dspct: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c6fplpm") @ExcludeMissing c6fplpm: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c6intel") @ExcludeMissing c6intel: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c6laser") @ExcludeMissing c6laser: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c6longpm")
            @ExcludeMissing
            c6longpm: JsonField<String> = JsonMissing.of(),
            @JsonProperty("c6tnr3") @ExcludeMissing c6tnr3: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c7elang2")
            @ExcludeMissing
            c7elang2: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("c7in3p") @ExcludeMissing c7in3p: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("c7tnor") @ExcludeMissing c7tnor: JsonField<String> = JsonMissing.of(),
            @JsonProperty("createdAt")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("createdBy")
            @ExcludeMissing
            createdBy: JsonField<String> = JsonMissing.of(),
            @JsonProperty("env") @ExcludeMissing env: JsonField<String> = JsonMissing.of(),
            @JsonProperty("index") @ExcludeMissing index: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("lat") @ExcludeMissing lat: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("lon") @ExcludeMissing lon: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("orginx") @ExcludeMissing orginx: JsonField<String> = JsonMissing.of(),
            @JsonProperty("origin") @ExcludeMissing origin: JsonField<String> = JsonMissing.of(),
            @JsonProperty("origNetwork")
            @ExcludeMissing
            origNetwork: JsonField<String> = JsonMissing.of(),
            @JsonProperty("rc") @ExcludeMissing rc: JsonField<String> = JsonMissing.of(),
            @JsonProperty("rr") @ExcludeMissing rr: JsonField<Int> = JsonMissing.of(),
            @JsonProperty("sz") @ExcludeMissing sz: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tno") @ExcludeMissing tno: JsonField<String> = JsonMissing.of(),
            @JsonProperty("trkId") @ExcludeMissing trkId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("twenv") @ExcludeMissing twenv: JsonField<String> = JsonMissing.of(),
        ) : this(
            classificationMarking,
            dataMode,
            mad,
            source,
            ts,
            bodyId,
            c1associateddmpis,
            c2air,
            c2alt,
            c2crs,
            c2exerciseindicator,
            c2exercisemof,
            c2id,
            c2idamplifyingdescriptor,
            c2lnd,
            c2spc,
            c2spd,
            c2specialinterestindicator,
            c2sur,
            c3elv,
            c3lat,
            c3lon,
            c3ptl,
            c3ptnum,
            c4colon,
            c4def,
            c4egress,
            c4mod,
            c4numberofstores,
            c4runin,
            c4tgt,
            c4timediscrete,
            c4tm,
            c4typeofstores,
            c5colon,
            c5elevationlsbs,
            c5haeadj,
            c5latlsb,
            c5lonlsb,
            c5tgtbrng,
            c5tw,
            c6dspc,
            c6dspct,
            c6fplpm,
            c6intel,
            c6laser,
            c6longpm,
            c6tnr3,
            c7elang2,
            c7in3p,
            c7tnor,
            createdAt,
            createdBy,
            env,
            index,
            lat,
            lon,
            orginx,
            origin,
            origNetwork,
            rc,
            rr,
            sz,
            tno,
            trkId,
            twenv,
            mutableMapOf(),
        )

        /**
         * Classification marking of the data in IC/CAPCO Portion-marked format.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun classificationMarking(): String =
            classificationMarking.getRequired("classificationMarking")

        /**
         * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
         *
         * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include
         * both real and simulated data.
         *
         * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and
         * analysis.
         *
         * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
         *
         * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
         * requirements, and for validating technical, functional, and performance characteristics.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun dataMode(): DataMode = dataMode.getRequired("dataMode")

        /**
         * The mission assignment discrete value.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun mad(): String = mad.getRequired("mad")

        /**
         * Source of the data.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun source(): String = source.getRequired("source")

        /**
         * The timestamp of the mission data, in ISO 8601 UTC format.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   or is unexpectedly missing or null (e.g. if the server responded with an unexpected
         *   value).
         */
        fun ts(): OffsetDateTime = ts.getRequired("ts")

        /**
         * Unique identifier of the record, auto-generated by the system.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun bodyId(): Optional<String> = bodyId.getOptional("id")

        /**
         * TARGET POSITION CONTINUATION WORD - number of associated dmpis.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c1associateddmpis(): Optional<Int> = c1associateddmpis.getOptional("c1associateddmpis")

        /**
         * TARGET DATA CONTINUATION WORD - air specific type, see TABLE B-21.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2air(): Optional<String> = c2air.getOptional("c2air")

        /**
         * TARGET DATA CONTINUATION WORD - altitude, 100 FT, 2047=NS.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2alt(): Optional<Int> = c2alt.getOptional("c2alt")

        /**
         * TARGET DATA CONTINUATION WORD - course in increments of 1 degree.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2crs(): Optional<Int> = c2crs.getOptional("c2crs")

        /**
         * TARGET DATA CONTINUATION WORD - exercise indicator.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2exerciseindicator(): Optional<String> =
            c2exerciseindicator.getOptional("c2exerciseindicator")

        /**
         * TARGET DATA CONTINUATION WORD - method of fire.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2exercisemof(): Optional<String> = c2exercisemof.getOptional("c2exercisemof")

        /**
         * TARGET DATA CONTINUATION WORD - identity.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2id(): Optional<String> = c2id.getOptional("c2id")

        /**
         * TARGET DATA CONTINUATION WORD - identity amplifying descriptor.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2idamplifyingdescriptor(): Optional<String> =
            c2idamplifyingdescriptor.getOptional("c2idamplifyingdescriptor")

        /**
         * TARGET DATA CONTINUATION WORD - land specific type, see TABLE B-21.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2lnd(): Optional<String> = c2lnd.getOptional("c2lnd")

        /**
         * TARGET DATA CONTINUATION WORD - space specific type, see TABLE B-39.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2spc(): Optional<String> = c2spc.getOptional("c2spc")

        /**
         * TARGET DATA CONTINUATION WORD - speed in 2 DM/HR, 2047=NS.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2spd(): Optional<Int> = c2spd.getOptional("c2spd")

        /**
         * TARGET DATA CONTINUATION WORD - special interest indicator.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2specialinterestindicator(): Optional<String> =
            c2specialinterestindicator.getOptional("c2specialinterestindicator")

        /**
         * TARGET DATA CONTINUATION WORD - surface specific type, see TABLE B-21.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c2sur(): Optional<String> = c2sur.getOptional("c2sur")

        /**
         * POINT LOCATION CONTINUATION WORD - elevation, 25 FT, 1023=NS.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c3elv(): Optional<Double> = c3elv.getOptional("c3elv")

        /**
         * POINT LOCATION CONTINUATION WORD - latitude, 0.0013 MINUTE.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c3lat(): Optional<Double> = c3lat.getOptional("c3lat")

        /**
         * POINT LOCATION CONTINUATION WORD - longitude, 0.0013 MINUTE.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c3lon(): Optional<Double> = c3lon.getOptional("c3lon")

        /**
         * TARGET DATA CONTINUATION WORD - point type 1.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c3ptl(): Optional<String> = c3ptl.getOptional("c3ptl")

        /**
         * TARGET DATA CONTINUATION WORD - point number.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c3ptnum(): Optional<String> = c3ptnum.getOptional("c3ptnum")

        /**
         * SURFACE ATTACK CONTINUATION WORD - minute.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4colon(): Optional<Int> = c4colon.getOptional("c4colon")

        /**
         * SURFACE ATTACK CONTINUATION WORD - target defenses.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4def(): Optional<String> = c4def.getOptional("c4def")

        /**
         * SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4egress(): Optional<Int> = c4egress.getOptional("c4egress")

        /**
         * SURFACE ATTACK CONTINUATION WORD - mode of delivery.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4mod(): Optional<Int> = c4mod.getOptional("c4mod")

        /**
         * SURFACE ATTACK CONTINUATION WORD - number of stores, NS=63.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4numberofstores(): Optional<Int> = c4numberofstores.getOptional("c4numberofstores")

        /**
         * SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4runin(): Optional<Int> = c4runin.getOptional("c4runin")

        /**
         * SURFACE ATTACK CONTINUATION WORD - target type - see TABLE B-32.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4tgt(): Optional<String> = c4tgt.getOptional("c4tgt")

        /**
         * SURFACE ATTACK CONTINUATION WORD - time discrete.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4timediscrete(): Optional<String> = c4timediscrete.getOptional("c4timediscrete")

        /**
         * SURFACE ATTACK CONTINUATION WORD - hour.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4tm(): Optional<Int> = c4tm.getOptional("c4tm")

        /**
         * SURFACE ATTACK CONTINUATION WORD - type of stores.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c4typeofstores(): Optional<Int> = c4typeofstores.getOptional("c4typeofstores")

        /**
         * SURFACE ATTACK CONTINUATION WORD - seconds in increments of 1 sec.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c5colon(): Optional<Int> = c5colon.getOptional("c5colon")

        /**
         * CONTINUATION WORD - used with c3_elv to double precision to approx 3 ft.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c5elevationlsbs(): Optional<Int> = c5elevationlsbs.getOptional("c5elevationlsbs")

        /**
         * CONTINUATION WORD - hae adjustment, measured in 3.125 FT.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c5haeadj(): Optional<Int> = c5haeadj.getOptional("c5haeadj")

        /**
         * CONTINUATION WORD - used with c3_lat to double precision to approx 4 ft.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c5latlsb(): Optional<Int> = c5latlsb.getOptional("c5latlsb")

        /**
         * CONTINUATION WORD - used with c3_lon to double precision to approx 4 ft.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c5lonlsb(): Optional<Int> = c5lonlsb.getOptional("c5lonlsb")

        /**
         * CONTINUATION WORD - target bearing.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c5tgtbrng(): Optional<Int> = c5tgtbrng.getOptional("c5tgtbrng")

        /**
         * CONTINUATION WORD - time window.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c5tw(): Optional<Int> = c5tw.getOptional("c5tw")

        /**
         * TARGETING CONTINUATION WORD - designator/seeker pulse code.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c6dspc(): Optional<String> = c6dspc.getOptional("c6dspc")

        /**
         * TARGETING CONTINUATION WORD - designator/seeker pulse code type.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c6dspct(): Optional<String> = c6dspct.getOptional("c6dspct")

        /**
         * TARGETING CONTINUATION WORD - first pulse/last pulse mode.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c6fplpm(): Optional<String> = c6fplpm.getOptional("c6fplpm")

        /**
         * TARGETING CONTINUATION WORD - index number, related, 0=NS.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c6intel(): Optional<Int> = c6intel.getOptional("c6intel")

        /**
         * TARGETING CONTINUATION WORD - laser illuminator code.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c6laser(): Optional<Int> = c6laser.getOptional("c6laser")

        /**
         * TARGETING CONTINUATION WORD - long pulse mode.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c6longpm(): Optional<String> = c6longpm.getOptional("c6longpm")

        /**
         * TARGETING CONTINUATION WORD - track number, related to 3.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c6tnr3(): Optional<Int> = c6tnr3.getOptional("c6tnr3")

        /**
         * THIRD PARTY CONTINUATION WORD - elevation angle, 2.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c7elang2(): Optional<Double> = c7elang2.getOptional("c7elang2")

        /**
         * THIRD PARTY CONTINUATION WORD - index number, third party.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c7in3p(): Optional<Int> = c7in3p.getOptional("c7in3p")

        /**
         * THIRD PARTY CONTINUATION WORD - track number, index originator.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun c7tnor(): Optional<String> = c7tnor.getOptional("c7tnor")

        /**
         * Time the row was created in the database, auto-populated by the system.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): Optional<OffsetDateTime> = createdAt.getOptional("createdAt")

        /**
         * Application user who created the row in the database, auto-populated by the system.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun createdBy(): Optional<String> = createdBy.getOptional("createdBy")

        /**
         * Environment.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun env(): Optional<String> = env.getOptional("env")

        /**
         * Index number.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun index(): Optional<Int> = index.getOptional("index")

        /**
         * WGS84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun lat(): Optional<Double> = lat.getOptional("lat")

        /**
         * WGS84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime
         * Meridian).
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun lon(): Optional<Double> = lon.getOptional("lon")

        /**
         * Origin of index number.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun orginx(): Optional<String> = orginx.getOptional("orginx")

        /**
         * Originating system or organization which produced the data, if different from the source.
         * The origin may be different than the source if the source was a mediating system which
         * forwarded the data on behalf of the origin system. If null, the source may be assumed to
         * be the origin.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun origin(): Optional<String> = origin.getOptional("origin")

        /**
         * The originating source network on which this record was created, auto-populated by the
         * system.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun origNetwork(): Optional<String> = origNetwork.getOptional("origNetwork")

        /**
         * Receipt/Compliance, values from TABLE B-9.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun rc(): Optional<String> = rc.getOptional("rc")

        /**
         * Recurrence rate, receipt/compliance.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun rr(): Optional<Int> = rr.getOptional("rr")

        /**
         * Strength.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun sz(): Optional<String> = sz.getOptional("sz")

        /**
         * Track number objective.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun tno(): Optional<String> = tno.getOptional("tno")

        /**
         * The track ID that the status is referencing, addressee.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun trkId(): Optional<String> = trkId.getOptional("trkId")

        /**
         * Threat warning environment.
         *
         * @throws UnifieddatalibraryInvalidDataException if the JSON field has an unexpected type
         *   (e.g. if the server responded with an unexpected value).
         */
        fun twenv(): Optional<String> = twenv.getOptional("twenv")

        /**
         * Returns the raw JSON value of [classificationMarking].
         *
         * Unlike [classificationMarking], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("classificationMarking")
        @ExcludeMissing
        fun _classificationMarking(): JsonField<String> = classificationMarking

        /**
         * Returns the raw JSON value of [dataMode].
         *
         * Unlike [dataMode], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("dataMode") @ExcludeMissing fun _dataMode(): JsonField<DataMode> = dataMode

        /**
         * Returns the raw JSON value of [mad].
         *
         * Unlike [mad], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("mad") @ExcludeMissing fun _mad(): JsonField<String> = mad

        /**
         * Returns the raw JSON value of [source].
         *
         * Unlike [source], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("source") @ExcludeMissing fun _source(): JsonField<String> = source

        /**
         * Returns the raw JSON value of [ts].
         *
         * Unlike [ts], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("ts") @ExcludeMissing fun _ts(): JsonField<OffsetDateTime> = ts

        /**
         * Returns the raw JSON value of [bodyId].
         *
         * Unlike [bodyId], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _bodyId(): JsonField<String> = bodyId

        /**
         * Returns the raw JSON value of [c1associateddmpis].
         *
         * Unlike [c1associateddmpis], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("c1associateddmpis")
        @ExcludeMissing
        fun _c1associateddmpis(): JsonField<Int> = c1associateddmpis

        /**
         * Returns the raw JSON value of [c2air].
         *
         * Unlike [c2air], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c2air") @ExcludeMissing fun _c2air(): JsonField<String> = c2air

        /**
         * Returns the raw JSON value of [c2alt].
         *
         * Unlike [c2alt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c2alt") @ExcludeMissing fun _c2alt(): JsonField<Int> = c2alt

        /**
         * Returns the raw JSON value of [c2crs].
         *
         * Unlike [c2crs], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c2crs") @ExcludeMissing fun _c2crs(): JsonField<Int> = c2crs

        /**
         * Returns the raw JSON value of [c2exerciseindicator].
         *
         * Unlike [c2exerciseindicator], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("c2exerciseindicator")
        @ExcludeMissing
        fun _c2exerciseindicator(): JsonField<String> = c2exerciseindicator

        /**
         * Returns the raw JSON value of [c2exercisemof].
         *
         * Unlike [c2exercisemof], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("c2exercisemof")
        @ExcludeMissing
        fun _c2exercisemof(): JsonField<String> = c2exercisemof

        /**
         * Returns the raw JSON value of [c2id].
         *
         * Unlike [c2id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c2id") @ExcludeMissing fun _c2id(): JsonField<String> = c2id

        /**
         * Returns the raw JSON value of [c2idamplifyingdescriptor].
         *
         * Unlike [c2idamplifyingdescriptor], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("c2idamplifyingdescriptor")
        @ExcludeMissing
        fun _c2idamplifyingdescriptor(): JsonField<String> = c2idamplifyingdescriptor

        /**
         * Returns the raw JSON value of [c2lnd].
         *
         * Unlike [c2lnd], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c2lnd") @ExcludeMissing fun _c2lnd(): JsonField<String> = c2lnd

        /**
         * Returns the raw JSON value of [c2spc].
         *
         * Unlike [c2spc], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c2spc") @ExcludeMissing fun _c2spc(): JsonField<String> = c2spc

        /**
         * Returns the raw JSON value of [c2spd].
         *
         * Unlike [c2spd], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c2spd") @ExcludeMissing fun _c2spd(): JsonField<Int> = c2spd

        /**
         * Returns the raw JSON value of [c2specialinterestindicator].
         *
         * Unlike [c2specialinterestindicator], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("c2specialinterestindicator")
        @ExcludeMissing
        fun _c2specialinterestindicator(): JsonField<String> = c2specialinterestindicator

        /**
         * Returns the raw JSON value of [c2sur].
         *
         * Unlike [c2sur], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c2sur") @ExcludeMissing fun _c2sur(): JsonField<String> = c2sur

        /**
         * Returns the raw JSON value of [c3elv].
         *
         * Unlike [c3elv], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c3elv") @ExcludeMissing fun _c3elv(): JsonField<Double> = c3elv

        /**
         * Returns the raw JSON value of [c3lat].
         *
         * Unlike [c3lat], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c3lat") @ExcludeMissing fun _c3lat(): JsonField<Double> = c3lat

        /**
         * Returns the raw JSON value of [c3lon].
         *
         * Unlike [c3lon], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c3lon") @ExcludeMissing fun _c3lon(): JsonField<Double> = c3lon

        /**
         * Returns the raw JSON value of [c3ptl].
         *
         * Unlike [c3ptl], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c3ptl") @ExcludeMissing fun _c3ptl(): JsonField<String> = c3ptl

        /**
         * Returns the raw JSON value of [c3ptnum].
         *
         * Unlike [c3ptnum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c3ptnum") @ExcludeMissing fun _c3ptnum(): JsonField<String> = c3ptnum

        /**
         * Returns the raw JSON value of [c4colon].
         *
         * Unlike [c4colon], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c4colon") @ExcludeMissing fun _c4colon(): JsonField<Int> = c4colon

        /**
         * Returns the raw JSON value of [c4def].
         *
         * Unlike [c4def], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c4def") @ExcludeMissing fun _c4def(): JsonField<String> = c4def

        /**
         * Returns the raw JSON value of [c4egress].
         *
         * Unlike [c4egress], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c4egress") @ExcludeMissing fun _c4egress(): JsonField<Int> = c4egress

        /**
         * Returns the raw JSON value of [c4mod].
         *
         * Unlike [c4mod], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c4mod") @ExcludeMissing fun _c4mod(): JsonField<Int> = c4mod

        /**
         * Returns the raw JSON value of [c4numberofstores].
         *
         * Unlike [c4numberofstores], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("c4numberofstores")
        @ExcludeMissing
        fun _c4numberofstores(): JsonField<Int> = c4numberofstores

        /**
         * Returns the raw JSON value of [c4runin].
         *
         * Unlike [c4runin], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c4runin") @ExcludeMissing fun _c4runin(): JsonField<Int> = c4runin

        /**
         * Returns the raw JSON value of [c4tgt].
         *
         * Unlike [c4tgt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c4tgt") @ExcludeMissing fun _c4tgt(): JsonField<String> = c4tgt

        /**
         * Returns the raw JSON value of [c4timediscrete].
         *
         * Unlike [c4timediscrete], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("c4timediscrete")
        @ExcludeMissing
        fun _c4timediscrete(): JsonField<String> = c4timediscrete

        /**
         * Returns the raw JSON value of [c4tm].
         *
         * Unlike [c4tm], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c4tm") @ExcludeMissing fun _c4tm(): JsonField<Int> = c4tm

        /**
         * Returns the raw JSON value of [c4typeofstores].
         *
         * Unlike [c4typeofstores], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("c4typeofstores")
        @ExcludeMissing
        fun _c4typeofstores(): JsonField<Int> = c4typeofstores

        /**
         * Returns the raw JSON value of [c5colon].
         *
         * Unlike [c5colon], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c5colon") @ExcludeMissing fun _c5colon(): JsonField<Int> = c5colon

        /**
         * Returns the raw JSON value of [c5elevationlsbs].
         *
         * Unlike [c5elevationlsbs], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("c5elevationlsbs")
        @ExcludeMissing
        fun _c5elevationlsbs(): JsonField<Int> = c5elevationlsbs

        /**
         * Returns the raw JSON value of [c5haeadj].
         *
         * Unlike [c5haeadj], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c5haeadj") @ExcludeMissing fun _c5haeadj(): JsonField<Int> = c5haeadj

        /**
         * Returns the raw JSON value of [c5latlsb].
         *
         * Unlike [c5latlsb], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c5latlsb") @ExcludeMissing fun _c5latlsb(): JsonField<Int> = c5latlsb

        /**
         * Returns the raw JSON value of [c5lonlsb].
         *
         * Unlike [c5lonlsb], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c5lonlsb") @ExcludeMissing fun _c5lonlsb(): JsonField<Int> = c5lonlsb

        /**
         * Returns the raw JSON value of [c5tgtbrng].
         *
         * Unlike [c5tgtbrng], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c5tgtbrng") @ExcludeMissing fun _c5tgtbrng(): JsonField<Int> = c5tgtbrng

        /**
         * Returns the raw JSON value of [c5tw].
         *
         * Unlike [c5tw], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c5tw") @ExcludeMissing fun _c5tw(): JsonField<Int> = c5tw

        /**
         * Returns the raw JSON value of [c6dspc].
         *
         * Unlike [c6dspc], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c6dspc") @ExcludeMissing fun _c6dspc(): JsonField<String> = c6dspc

        /**
         * Returns the raw JSON value of [c6dspct].
         *
         * Unlike [c6dspct], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c6dspct") @ExcludeMissing fun _c6dspct(): JsonField<String> = c6dspct

        /**
         * Returns the raw JSON value of [c6fplpm].
         *
         * Unlike [c6fplpm], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c6fplpm") @ExcludeMissing fun _c6fplpm(): JsonField<String> = c6fplpm

        /**
         * Returns the raw JSON value of [c6intel].
         *
         * Unlike [c6intel], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c6intel") @ExcludeMissing fun _c6intel(): JsonField<Int> = c6intel

        /**
         * Returns the raw JSON value of [c6laser].
         *
         * Unlike [c6laser], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c6laser") @ExcludeMissing fun _c6laser(): JsonField<Int> = c6laser

        /**
         * Returns the raw JSON value of [c6longpm].
         *
         * Unlike [c6longpm], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c6longpm") @ExcludeMissing fun _c6longpm(): JsonField<String> = c6longpm

        /**
         * Returns the raw JSON value of [c6tnr3].
         *
         * Unlike [c6tnr3], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c6tnr3") @ExcludeMissing fun _c6tnr3(): JsonField<Int> = c6tnr3

        /**
         * Returns the raw JSON value of [c7elang2].
         *
         * Unlike [c7elang2], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c7elang2") @ExcludeMissing fun _c7elang2(): JsonField<Double> = c7elang2

        /**
         * Returns the raw JSON value of [c7in3p].
         *
         * Unlike [c7in3p], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c7in3p") @ExcludeMissing fun _c7in3p(): JsonField<Int> = c7in3p

        /**
         * Returns the raw JSON value of [c7tnor].
         *
         * Unlike [c7tnor], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("c7tnor") @ExcludeMissing fun _c7tnor(): JsonField<String> = c7tnor

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("createdAt")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [createdBy].
         *
         * Unlike [createdBy], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("createdBy") @ExcludeMissing fun _createdBy(): JsonField<String> = createdBy

        /**
         * Returns the raw JSON value of [env].
         *
         * Unlike [env], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("env") @ExcludeMissing fun _env(): JsonField<String> = env

        /**
         * Returns the raw JSON value of [index].
         *
         * Unlike [index], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("index") @ExcludeMissing fun _index(): JsonField<Int> = index

        /**
         * Returns the raw JSON value of [lat].
         *
         * Unlike [lat], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("lat") @ExcludeMissing fun _lat(): JsonField<Double> = lat

        /**
         * Returns the raw JSON value of [lon].
         *
         * Unlike [lon], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("lon") @ExcludeMissing fun _lon(): JsonField<Double> = lon

        /**
         * Returns the raw JSON value of [orginx].
         *
         * Unlike [orginx], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("orginx") @ExcludeMissing fun _orginx(): JsonField<String> = orginx

        /**
         * Returns the raw JSON value of [origin].
         *
         * Unlike [origin], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("origin") @ExcludeMissing fun _origin(): JsonField<String> = origin

        /**
         * Returns the raw JSON value of [origNetwork].
         *
         * Unlike [origNetwork], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("origNetwork")
        @ExcludeMissing
        fun _origNetwork(): JsonField<String> = origNetwork

        /**
         * Returns the raw JSON value of [rc].
         *
         * Unlike [rc], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("rc") @ExcludeMissing fun _rc(): JsonField<String> = rc

        /**
         * Returns the raw JSON value of [rr].
         *
         * Unlike [rr], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("rr") @ExcludeMissing fun _rr(): JsonField<Int> = rr

        /**
         * Returns the raw JSON value of [sz].
         *
         * Unlike [sz], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("sz") @ExcludeMissing fun _sz(): JsonField<String> = sz

        /**
         * Returns the raw JSON value of [tno].
         *
         * Unlike [tno], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("tno") @ExcludeMissing fun _tno(): JsonField<String> = tno

        /**
         * Returns the raw JSON value of [trkId].
         *
         * Unlike [trkId], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("trkId") @ExcludeMissing fun _trkId(): JsonField<String> = trkId

        /**
         * Returns the raw JSON value of [twenv].
         *
         * Unlike [twenv], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("twenv") @ExcludeMissing fun _twenv(): JsonField<String> = twenv

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Body].
             *
             * The following fields are required:
             * ```java
             * .classificationMarking()
             * .dataMode()
             * .mad()
             * .source()
             * .ts()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Body]. */
        class Builder internal constructor() {

            private var classificationMarking: JsonField<String>? = null
            private var dataMode: JsonField<DataMode>? = null
            private var mad: JsonField<String>? = null
            private var source: JsonField<String>? = null
            private var ts: JsonField<OffsetDateTime>? = null
            private var bodyId: JsonField<String> = JsonMissing.of()
            private var c1associateddmpis: JsonField<Int> = JsonMissing.of()
            private var c2air: JsonField<String> = JsonMissing.of()
            private var c2alt: JsonField<Int> = JsonMissing.of()
            private var c2crs: JsonField<Int> = JsonMissing.of()
            private var c2exerciseindicator: JsonField<String> = JsonMissing.of()
            private var c2exercisemof: JsonField<String> = JsonMissing.of()
            private var c2id: JsonField<String> = JsonMissing.of()
            private var c2idamplifyingdescriptor: JsonField<String> = JsonMissing.of()
            private var c2lnd: JsonField<String> = JsonMissing.of()
            private var c2spc: JsonField<String> = JsonMissing.of()
            private var c2spd: JsonField<Int> = JsonMissing.of()
            private var c2specialinterestindicator: JsonField<String> = JsonMissing.of()
            private var c2sur: JsonField<String> = JsonMissing.of()
            private var c3elv: JsonField<Double> = JsonMissing.of()
            private var c3lat: JsonField<Double> = JsonMissing.of()
            private var c3lon: JsonField<Double> = JsonMissing.of()
            private var c3ptl: JsonField<String> = JsonMissing.of()
            private var c3ptnum: JsonField<String> = JsonMissing.of()
            private var c4colon: JsonField<Int> = JsonMissing.of()
            private var c4def: JsonField<String> = JsonMissing.of()
            private var c4egress: JsonField<Int> = JsonMissing.of()
            private var c4mod: JsonField<Int> = JsonMissing.of()
            private var c4numberofstores: JsonField<Int> = JsonMissing.of()
            private var c4runin: JsonField<Int> = JsonMissing.of()
            private var c4tgt: JsonField<String> = JsonMissing.of()
            private var c4timediscrete: JsonField<String> = JsonMissing.of()
            private var c4tm: JsonField<Int> = JsonMissing.of()
            private var c4typeofstores: JsonField<Int> = JsonMissing.of()
            private var c5colon: JsonField<Int> = JsonMissing.of()
            private var c5elevationlsbs: JsonField<Int> = JsonMissing.of()
            private var c5haeadj: JsonField<Int> = JsonMissing.of()
            private var c5latlsb: JsonField<Int> = JsonMissing.of()
            private var c5lonlsb: JsonField<Int> = JsonMissing.of()
            private var c5tgtbrng: JsonField<Int> = JsonMissing.of()
            private var c5tw: JsonField<Int> = JsonMissing.of()
            private var c6dspc: JsonField<String> = JsonMissing.of()
            private var c6dspct: JsonField<String> = JsonMissing.of()
            private var c6fplpm: JsonField<String> = JsonMissing.of()
            private var c6intel: JsonField<Int> = JsonMissing.of()
            private var c6laser: JsonField<Int> = JsonMissing.of()
            private var c6longpm: JsonField<String> = JsonMissing.of()
            private var c6tnr3: JsonField<Int> = JsonMissing.of()
            private var c7elang2: JsonField<Double> = JsonMissing.of()
            private var c7in3p: JsonField<Int> = JsonMissing.of()
            private var c7tnor: JsonField<String> = JsonMissing.of()
            private var createdAt: JsonField<OffsetDateTime> = JsonMissing.of()
            private var createdBy: JsonField<String> = JsonMissing.of()
            private var env: JsonField<String> = JsonMissing.of()
            private var index: JsonField<Int> = JsonMissing.of()
            private var lat: JsonField<Double> = JsonMissing.of()
            private var lon: JsonField<Double> = JsonMissing.of()
            private var orginx: JsonField<String> = JsonMissing.of()
            private var origin: JsonField<String> = JsonMissing.of()
            private var origNetwork: JsonField<String> = JsonMissing.of()
            private var rc: JsonField<String> = JsonMissing.of()
            private var rr: JsonField<Int> = JsonMissing.of()
            private var sz: JsonField<String> = JsonMissing.of()
            private var tno: JsonField<String> = JsonMissing.of()
            private var trkId: JsonField<String> = JsonMissing.of()
            private var twenv: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(body: Body) = apply {
                classificationMarking = body.classificationMarking
                dataMode = body.dataMode
                mad = body.mad
                source = body.source
                ts = body.ts
                bodyId = body.bodyId
                c1associateddmpis = body.c1associateddmpis
                c2air = body.c2air
                c2alt = body.c2alt
                c2crs = body.c2crs
                c2exerciseindicator = body.c2exerciseindicator
                c2exercisemof = body.c2exercisemof
                c2id = body.c2id
                c2idamplifyingdescriptor = body.c2idamplifyingdescriptor
                c2lnd = body.c2lnd
                c2spc = body.c2spc
                c2spd = body.c2spd
                c2specialinterestindicator = body.c2specialinterestindicator
                c2sur = body.c2sur
                c3elv = body.c3elv
                c3lat = body.c3lat
                c3lon = body.c3lon
                c3ptl = body.c3ptl
                c3ptnum = body.c3ptnum
                c4colon = body.c4colon
                c4def = body.c4def
                c4egress = body.c4egress
                c4mod = body.c4mod
                c4numberofstores = body.c4numberofstores
                c4runin = body.c4runin
                c4tgt = body.c4tgt
                c4timediscrete = body.c4timediscrete
                c4tm = body.c4tm
                c4typeofstores = body.c4typeofstores
                c5colon = body.c5colon
                c5elevationlsbs = body.c5elevationlsbs
                c5haeadj = body.c5haeadj
                c5latlsb = body.c5latlsb
                c5lonlsb = body.c5lonlsb
                c5tgtbrng = body.c5tgtbrng
                c5tw = body.c5tw
                c6dspc = body.c6dspc
                c6dspct = body.c6dspct
                c6fplpm = body.c6fplpm
                c6intel = body.c6intel
                c6laser = body.c6laser
                c6longpm = body.c6longpm
                c6tnr3 = body.c6tnr3
                c7elang2 = body.c7elang2
                c7in3p = body.c7in3p
                c7tnor = body.c7tnor
                createdAt = body.createdAt
                createdBy = body.createdBy
                env = body.env
                index = body.index
                lat = body.lat
                lon = body.lon
                orginx = body.orginx
                origin = body.origin
                origNetwork = body.origNetwork
                rc = body.rc
                rr = body.rr
                sz = body.sz
                tno = body.tno
                trkId = body.trkId
                twenv = body.twenv
                additionalProperties = body.additionalProperties.toMutableMap()
            }

            /** Classification marking of the data in IC/CAPCO Portion-marked format. */
            fun classificationMarking(classificationMarking: String) =
                classificationMarking(JsonField.of(classificationMarking))

            /**
             * Sets [Builder.classificationMarking] to an arbitrary JSON value.
             *
             * You should usually call [Builder.classificationMarking] with a well-typed [String]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun classificationMarking(classificationMarking: JsonField<String>) = apply {
                this.classificationMarking = classificationMarking
            }

            /**
             * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
             *
             * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may
             * include both real and simulated data.
             *
             * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events,
             * and analysis.
             *
             * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
             *
             * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
             * requirements, and for validating technical, functional, and performance
             * characteristics.
             */
            fun dataMode(dataMode: DataMode) = dataMode(JsonField.of(dataMode))

            /**
             * Sets [Builder.dataMode] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dataMode] with a well-typed [DataMode] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun dataMode(dataMode: JsonField<DataMode>) = apply { this.dataMode = dataMode }

            /** The mission assignment discrete value. */
            fun mad(mad: String) = mad(JsonField.of(mad))

            /**
             * Sets [Builder.mad] to an arbitrary JSON value.
             *
             * You should usually call [Builder.mad] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun mad(mad: JsonField<String>) = apply { this.mad = mad }

            /** Source of the data. */
            fun source(source: String) = source(JsonField.of(source))

            /**
             * Sets [Builder.source] to an arbitrary JSON value.
             *
             * You should usually call [Builder.source] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun source(source: JsonField<String>) = apply { this.source = source }

            /** The timestamp of the mission data, in ISO 8601 UTC format. */
            fun ts(ts: OffsetDateTime) = ts(JsonField.of(ts))

            /**
             * Sets [Builder.ts] to an arbitrary JSON value.
             *
             * You should usually call [Builder.ts] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun ts(ts: JsonField<OffsetDateTime>) = apply { this.ts = ts }

            /** Unique identifier of the record, auto-generated by the system. */
            fun bodyId(bodyId: String) = bodyId(JsonField.of(bodyId))

            /**
             * Sets [Builder.bodyId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bodyId] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun bodyId(bodyId: JsonField<String>) = apply { this.bodyId = bodyId }

            /** TARGET POSITION CONTINUATION WORD - number of associated dmpis. */
            fun c1associateddmpis(c1associateddmpis: Int) =
                c1associateddmpis(JsonField.of(c1associateddmpis))

            /**
             * Sets [Builder.c1associateddmpis] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c1associateddmpis] with a well-typed [Int] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c1associateddmpis(c1associateddmpis: JsonField<Int>) = apply {
                this.c1associateddmpis = c1associateddmpis
            }

            /** TARGET DATA CONTINUATION WORD - air specific type, see TABLE B-21. */
            fun c2air(c2air: String) = c2air(JsonField.of(c2air))

            /**
             * Sets [Builder.c2air] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2air] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c2air(c2air: JsonField<String>) = apply { this.c2air = c2air }

            /** TARGET DATA CONTINUATION WORD - altitude, 100 FT, 2047=NS. */
            fun c2alt(c2alt: Int) = c2alt(JsonField.of(c2alt))

            /**
             * Sets [Builder.c2alt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2alt] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c2alt(c2alt: JsonField<Int>) = apply { this.c2alt = c2alt }

            /** TARGET DATA CONTINUATION WORD - course in increments of 1 degree. */
            fun c2crs(c2crs: Int) = c2crs(JsonField.of(c2crs))

            /**
             * Sets [Builder.c2crs] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2crs] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c2crs(c2crs: JsonField<Int>) = apply { this.c2crs = c2crs }

            /** TARGET DATA CONTINUATION WORD - exercise indicator. */
            fun c2exerciseindicator(c2exerciseindicator: String) =
                c2exerciseindicator(JsonField.of(c2exerciseindicator))

            /**
             * Sets [Builder.c2exerciseindicator] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2exerciseindicator] with a well-typed [String]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun c2exerciseindicator(c2exerciseindicator: JsonField<String>) = apply {
                this.c2exerciseindicator = c2exerciseindicator
            }

            /** TARGET DATA CONTINUATION WORD - method of fire. */
            fun c2exercisemof(c2exercisemof: String) = c2exercisemof(JsonField.of(c2exercisemof))

            /**
             * Sets [Builder.c2exercisemof] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2exercisemof] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c2exercisemof(c2exercisemof: JsonField<String>) = apply {
                this.c2exercisemof = c2exercisemof
            }

            /** TARGET DATA CONTINUATION WORD - identity. */
            fun c2id(c2id: String) = c2id(JsonField.of(c2id))

            /**
             * Sets [Builder.c2id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c2id(c2id: JsonField<String>) = apply { this.c2id = c2id }

            /** TARGET DATA CONTINUATION WORD - identity amplifying descriptor. */
            fun c2idamplifyingdescriptor(c2idamplifyingdescriptor: String) =
                c2idamplifyingdescriptor(JsonField.of(c2idamplifyingdescriptor))

            /**
             * Sets [Builder.c2idamplifyingdescriptor] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2idamplifyingdescriptor] with a well-typed [String]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun c2idamplifyingdescriptor(c2idamplifyingdescriptor: JsonField<String>) = apply {
                this.c2idamplifyingdescriptor = c2idamplifyingdescriptor
            }

            /** TARGET DATA CONTINUATION WORD - land specific type, see TABLE B-21. */
            fun c2lnd(c2lnd: String) = c2lnd(JsonField.of(c2lnd))

            /**
             * Sets [Builder.c2lnd] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2lnd] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c2lnd(c2lnd: JsonField<String>) = apply { this.c2lnd = c2lnd }

            /** TARGET DATA CONTINUATION WORD - space specific type, see TABLE B-39. */
            fun c2spc(c2spc: String) = c2spc(JsonField.of(c2spc))

            /**
             * Sets [Builder.c2spc] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2spc] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c2spc(c2spc: JsonField<String>) = apply { this.c2spc = c2spc }

            /** TARGET DATA CONTINUATION WORD - speed in 2 DM/HR, 2047=NS. */
            fun c2spd(c2spd: Int) = c2spd(JsonField.of(c2spd))

            /**
             * Sets [Builder.c2spd] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2spd] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c2spd(c2spd: JsonField<Int>) = apply { this.c2spd = c2spd }

            /** TARGET DATA CONTINUATION WORD - special interest indicator. */
            fun c2specialinterestindicator(c2specialinterestindicator: String) =
                c2specialinterestindicator(JsonField.of(c2specialinterestindicator))

            /**
             * Sets [Builder.c2specialinterestindicator] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2specialinterestindicator] with a well-typed
             * [String] value instead. This method is primarily for setting the field to an
             * undocumented or not yet supported value.
             */
            fun c2specialinterestindicator(c2specialinterestindicator: JsonField<String>) = apply {
                this.c2specialinterestindicator = c2specialinterestindicator
            }

            /** TARGET DATA CONTINUATION WORD - surface specific type, see TABLE B-21. */
            fun c2sur(c2sur: String) = c2sur(JsonField.of(c2sur))

            /**
             * Sets [Builder.c2sur] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c2sur] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c2sur(c2sur: JsonField<String>) = apply { this.c2sur = c2sur }

            /** POINT LOCATION CONTINUATION WORD - elevation, 25 FT, 1023=NS. */
            fun c3elv(c3elv: Double) = c3elv(JsonField.of(c3elv))

            /**
             * Sets [Builder.c3elv] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c3elv] with a well-typed [Double] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c3elv(c3elv: JsonField<Double>) = apply { this.c3elv = c3elv }

            /** POINT LOCATION CONTINUATION WORD - latitude, 0.0013 MINUTE. */
            fun c3lat(c3lat: Double) = c3lat(JsonField.of(c3lat))

            /**
             * Sets [Builder.c3lat] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c3lat] with a well-typed [Double] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c3lat(c3lat: JsonField<Double>) = apply { this.c3lat = c3lat }

            /** POINT LOCATION CONTINUATION WORD - longitude, 0.0013 MINUTE. */
            fun c3lon(c3lon: Double) = c3lon(JsonField.of(c3lon))

            /**
             * Sets [Builder.c3lon] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c3lon] with a well-typed [Double] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c3lon(c3lon: JsonField<Double>) = apply { this.c3lon = c3lon }

            /** TARGET DATA CONTINUATION WORD - point type 1. */
            fun c3ptl(c3ptl: String) = c3ptl(JsonField.of(c3ptl))

            /**
             * Sets [Builder.c3ptl] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c3ptl] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c3ptl(c3ptl: JsonField<String>) = apply { this.c3ptl = c3ptl }

            /** TARGET DATA CONTINUATION WORD - point number. */
            fun c3ptnum(c3ptnum: String) = c3ptnum(JsonField.of(c3ptnum))

            /**
             * Sets [Builder.c3ptnum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c3ptnum] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c3ptnum(c3ptnum: JsonField<String>) = apply { this.c3ptnum = c3ptnum }

            /** SURFACE ATTACK CONTINUATION WORD - minute. */
            fun c4colon(c4colon: Int) = c4colon(JsonField.of(c4colon))

            /**
             * Sets [Builder.c4colon] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4colon] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c4colon(c4colon: JsonField<Int>) = apply { this.c4colon = c4colon }

            /** SURFACE ATTACK CONTINUATION WORD - target defenses. */
            fun c4def(c4def: String) = c4def(JsonField.of(c4def))

            /**
             * Sets [Builder.c4def] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4def] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c4def(c4def: JsonField<String>) = apply { this.c4def = c4def }

            /** SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511. */
            fun c4egress(c4egress: Int) = c4egress(JsonField.of(c4egress))

            /**
             * Sets [Builder.c4egress] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4egress] with a well-typed [Int] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c4egress(c4egress: JsonField<Int>) = apply { this.c4egress = c4egress }

            /** SURFACE ATTACK CONTINUATION WORD - mode of delivery. */
            fun c4mod(c4mod: Int) = c4mod(JsonField.of(c4mod))

            /**
             * Sets [Builder.c4mod] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4mod] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c4mod(c4mod: JsonField<Int>) = apply { this.c4mod = c4mod }

            /** SURFACE ATTACK CONTINUATION WORD - number of stores, NS=63. */
            fun c4numberofstores(c4numberofstores: Int) =
                c4numberofstores(JsonField.of(c4numberofstores))

            /**
             * Sets [Builder.c4numberofstores] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4numberofstores] with a well-typed [Int] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c4numberofstores(c4numberofstores: JsonField<Int>) = apply {
                this.c4numberofstores = c4numberofstores
            }

            /** SURFACE ATTACK CONTINUATION WORD - run in heading, NS=511. */
            fun c4runin(c4runin: Int) = c4runin(JsonField.of(c4runin))

            /**
             * Sets [Builder.c4runin] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4runin] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c4runin(c4runin: JsonField<Int>) = apply { this.c4runin = c4runin }

            /** SURFACE ATTACK CONTINUATION WORD - target type - see TABLE B-32. */
            fun c4tgt(c4tgt: String) = c4tgt(JsonField.of(c4tgt))

            /**
             * Sets [Builder.c4tgt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4tgt] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c4tgt(c4tgt: JsonField<String>) = apply { this.c4tgt = c4tgt }

            /** SURFACE ATTACK CONTINUATION WORD - time discrete. */
            fun c4timediscrete(c4timediscrete: String) =
                c4timediscrete(JsonField.of(c4timediscrete))

            /**
             * Sets [Builder.c4timediscrete] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4timediscrete] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c4timediscrete(c4timediscrete: JsonField<String>) = apply {
                this.c4timediscrete = c4timediscrete
            }

            /** SURFACE ATTACK CONTINUATION WORD - hour. */
            fun c4tm(c4tm: Int) = c4tm(JsonField.of(c4tm))

            /**
             * Sets [Builder.c4tm] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4tm] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c4tm(c4tm: JsonField<Int>) = apply { this.c4tm = c4tm }

            /** SURFACE ATTACK CONTINUATION WORD - type of stores. */
            fun c4typeofstores(c4typeofstores: Int) = c4typeofstores(JsonField.of(c4typeofstores))

            /**
             * Sets [Builder.c4typeofstores] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c4typeofstores] with a well-typed [Int] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c4typeofstores(c4typeofstores: JsonField<Int>) = apply {
                this.c4typeofstores = c4typeofstores
            }

            /** SURFACE ATTACK CONTINUATION WORD - seconds in increments of 1 sec. */
            fun c5colon(c5colon: Int) = c5colon(JsonField.of(c5colon))

            /**
             * Sets [Builder.c5colon] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c5colon] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c5colon(c5colon: JsonField<Int>) = apply { this.c5colon = c5colon }

            /** CONTINUATION WORD - used with c3_elv to double precision to approx 3 ft. */
            fun c5elevationlsbs(c5elevationlsbs: Int) =
                c5elevationlsbs(JsonField.of(c5elevationlsbs))

            /**
             * Sets [Builder.c5elevationlsbs] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c5elevationlsbs] with a well-typed [Int] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c5elevationlsbs(c5elevationlsbs: JsonField<Int>) = apply {
                this.c5elevationlsbs = c5elevationlsbs
            }

            /** CONTINUATION WORD - hae adjustment, measured in 3.125 FT. */
            fun c5haeadj(c5haeadj: Int) = c5haeadj(JsonField.of(c5haeadj))

            /**
             * Sets [Builder.c5haeadj] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c5haeadj] with a well-typed [Int] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c5haeadj(c5haeadj: JsonField<Int>) = apply { this.c5haeadj = c5haeadj }

            /** CONTINUATION WORD - used with c3_lat to double precision to approx 4 ft. */
            fun c5latlsb(c5latlsb: Int) = c5latlsb(JsonField.of(c5latlsb))

            /**
             * Sets [Builder.c5latlsb] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c5latlsb] with a well-typed [Int] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c5latlsb(c5latlsb: JsonField<Int>) = apply { this.c5latlsb = c5latlsb }

            /** CONTINUATION WORD - used with c3_lon to double precision to approx 4 ft. */
            fun c5lonlsb(c5lonlsb: Int) = c5lonlsb(JsonField.of(c5lonlsb))

            /**
             * Sets [Builder.c5lonlsb] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c5lonlsb] with a well-typed [Int] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c5lonlsb(c5lonlsb: JsonField<Int>) = apply { this.c5lonlsb = c5lonlsb }

            /** CONTINUATION WORD - target bearing. */
            fun c5tgtbrng(c5tgtbrng: Int) = c5tgtbrng(JsonField.of(c5tgtbrng))

            /**
             * Sets [Builder.c5tgtbrng] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c5tgtbrng] with a well-typed [Int] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c5tgtbrng(c5tgtbrng: JsonField<Int>) = apply { this.c5tgtbrng = c5tgtbrng }

            /** CONTINUATION WORD - time window. */
            fun c5tw(c5tw: Int) = c5tw(JsonField.of(c5tw))

            /**
             * Sets [Builder.c5tw] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c5tw] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c5tw(c5tw: JsonField<Int>) = apply { this.c5tw = c5tw }

            /** TARGETING CONTINUATION WORD - designator/seeker pulse code. */
            fun c6dspc(c6dspc: String) = c6dspc(JsonField.of(c6dspc))

            /**
             * Sets [Builder.c6dspc] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c6dspc] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c6dspc(c6dspc: JsonField<String>) = apply { this.c6dspc = c6dspc }

            /** TARGETING CONTINUATION WORD - designator/seeker pulse code type. */
            fun c6dspct(c6dspct: String) = c6dspct(JsonField.of(c6dspct))

            /**
             * Sets [Builder.c6dspct] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c6dspct] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c6dspct(c6dspct: JsonField<String>) = apply { this.c6dspct = c6dspct }

            /** TARGETING CONTINUATION WORD - first pulse/last pulse mode. */
            fun c6fplpm(c6fplpm: String) = c6fplpm(JsonField.of(c6fplpm))

            /**
             * Sets [Builder.c6fplpm] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c6fplpm] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c6fplpm(c6fplpm: JsonField<String>) = apply { this.c6fplpm = c6fplpm }

            /** TARGETING CONTINUATION WORD - index number, related, 0=NS. */
            fun c6intel(c6intel: Int) = c6intel(JsonField.of(c6intel))

            /**
             * Sets [Builder.c6intel] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c6intel] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c6intel(c6intel: JsonField<Int>) = apply { this.c6intel = c6intel }

            /** TARGETING CONTINUATION WORD - laser illuminator code. */
            fun c6laser(c6laser: Int) = c6laser(JsonField.of(c6laser))

            /**
             * Sets [Builder.c6laser] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c6laser] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c6laser(c6laser: JsonField<Int>) = apply { this.c6laser = c6laser }

            /** TARGETING CONTINUATION WORD - long pulse mode. */
            fun c6longpm(c6longpm: String) = c6longpm(JsonField.of(c6longpm))

            /**
             * Sets [Builder.c6longpm] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c6longpm] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c6longpm(c6longpm: JsonField<String>) = apply { this.c6longpm = c6longpm }

            /** TARGETING CONTINUATION WORD - track number, related to 3. */
            fun c6tnr3(c6tnr3: Int) = c6tnr3(JsonField.of(c6tnr3))

            /**
             * Sets [Builder.c6tnr3] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c6tnr3] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c6tnr3(c6tnr3: JsonField<Int>) = apply { this.c6tnr3 = c6tnr3 }

            /** THIRD PARTY CONTINUATION WORD - elevation angle, 2. */
            fun c7elang2(c7elang2: Double) = c7elang2(JsonField.of(c7elang2))

            /**
             * Sets [Builder.c7elang2] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c7elang2] with a well-typed [Double] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c7elang2(c7elang2: JsonField<Double>) = apply { this.c7elang2 = c7elang2 }

            /** THIRD PARTY CONTINUATION WORD - index number, third party. */
            fun c7in3p(c7in3p: Int) = c7in3p(JsonField.of(c7in3p))

            /**
             * Sets [Builder.c7in3p] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c7in3p] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun c7in3p(c7in3p: JsonField<Int>) = apply { this.c7in3p = c7in3p }

            /** THIRD PARTY CONTINUATION WORD - track number, index originator. */
            fun c7tnor(c7tnor: String) = c7tnor(JsonField.of(c7tnor))

            /**
             * Sets [Builder.c7tnor] to an arbitrary JSON value.
             *
             * You should usually call [Builder.c7tnor] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun c7tnor(c7tnor: JsonField<String>) = apply { this.c7tnor = c7tnor }

            /** Time the row was created in the database, auto-populated by the system. */
            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            /**
             * Application user who created the row in the database, auto-populated by the system.
             */
            fun createdBy(createdBy: String) = createdBy(JsonField.of(createdBy))

            /**
             * Sets [Builder.createdBy] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdBy] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdBy(createdBy: JsonField<String>) = apply { this.createdBy = createdBy }

            /** Environment. */
            fun env(env: String) = env(JsonField.of(env))

            /**
             * Sets [Builder.env] to an arbitrary JSON value.
             *
             * You should usually call [Builder.env] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun env(env: JsonField<String>) = apply { this.env = env }

            /** Index number. */
            fun index(index: Int) = index(JsonField.of(index))

            /**
             * Sets [Builder.index] to an arbitrary JSON value.
             *
             * You should usually call [Builder.index] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun index(index: JsonField<Int>) = apply { this.index = index }

            /** WGS84 latitude, in degrees. -90 to 90 degrees (negative values south of equator). */
            fun lat(lat: Double) = lat(JsonField.of(lat))

            /**
             * Sets [Builder.lat] to an arbitrary JSON value.
             *
             * You should usually call [Builder.lat] with a well-typed [Double] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun lat(lat: JsonField<Double>) = apply { this.lat = lat }

            /**
             * WGS84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime
             * Meridian).
             */
            fun lon(lon: Double) = lon(JsonField.of(lon))

            /**
             * Sets [Builder.lon] to an arbitrary JSON value.
             *
             * You should usually call [Builder.lon] with a well-typed [Double] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun lon(lon: JsonField<Double>) = apply { this.lon = lon }

            /** Origin of index number. */
            fun orginx(orginx: String) = orginx(JsonField.of(orginx))

            /**
             * Sets [Builder.orginx] to an arbitrary JSON value.
             *
             * You should usually call [Builder.orginx] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun orginx(orginx: JsonField<String>) = apply { this.orginx = orginx }

            /**
             * Originating system or organization which produced the data, if different from the
             * source. The origin may be different than the source if the source was a mediating
             * system which forwarded the data on behalf of the origin system. If null, the source
             * may be assumed to be the origin.
             */
            fun origin(origin: String) = origin(JsonField.of(origin))

            /**
             * Sets [Builder.origin] to an arbitrary JSON value.
             *
             * You should usually call [Builder.origin] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun origin(origin: JsonField<String>) = apply { this.origin = origin }

            /**
             * The originating source network on which this record was created, auto-populated by
             * the system.
             */
            fun origNetwork(origNetwork: String) = origNetwork(JsonField.of(origNetwork))

            /**
             * Sets [Builder.origNetwork] to an arbitrary JSON value.
             *
             * You should usually call [Builder.origNetwork] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun origNetwork(origNetwork: JsonField<String>) = apply {
                this.origNetwork = origNetwork
            }

            /** Receipt/Compliance, values from TABLE B-9. */
            fun rc(rc: String) = rc(JsonField.of(rc))

            /**
             * Sets [Builder.rc] to an arbitrary JSON value.
             *
             * You should usually call [Builder.rc] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun rc(rc: JsonField<String>) = apply { this.rc = rc }

            /** Recurrence rate, receipt/compliance. */
            fun rr(rr: Int) = rr(JsonField.of(rr))

            /**
             * Sets [Builder.rr] to an arbitrary JSON value.
             *
             * You should usually call [Builder.rr] with a well-typed [Int] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun rr(rr: JsonField<Int>) = apply { this.rr = rr }

            /** Strength. */
            fun sz(sz: String) = sz(JsonField.of(sz))

            /**
             * Sets [Builder.sz] to an arbitrary JSON value.
             *
             * You should usually call [Builder.sz] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun sz(sz: JsonField<String>) = apply { this.sz = sz }

            /** Track number objective. */
            fun tno(tno: String) = tno(JsonField.of(tno))

            /**
             * Sets [Builder.tno] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tno] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun tno(tno: JsonField<String>) = apply { this.tno = tno }

            /** The track ID that the status is referencing, addressee. */
            fun trkId(trkId: String) = trkId(JsonField.of(trkId))

            /**
             * Sets [Builder.trkId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.trkId] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun trkId(trkId: JsonField<String>) = apply { this.trkId = trkId }

            /** Threat warning environment. */
            fun twenv(twenv: String) = twenv(JsonField.of(twenv))

            /**
             * Sets [Builder.twenv] to an arbitrary JSON value.
             *
             * You should usually call [Builder.twenv] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun twenv(twenv: JsonField<String>) = apply { this.twenv = twenv }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Body].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .classificationMarking()
             * .dataMode()
             * .mad()
             * .source()
             * .ts()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Body =
                Body(
                    checkRequired("classificationMarking", classificationMarking),
                    checkRequired("dataMode", dataMode),
                    checkRequired("mad", mad),
                    checkRequired("source", source),
                    checkRequired("ts", ts),
                    bodyId,
                    c1associateddmpis,
                    c2air,
                    c2alt,
                    c2crs,
                    c2exerciseindicator,
                    c2exercisemof,
                    c2id,
                    c2idamplifyingdescriptor,
                    c2lnd,
                    c2spc,
                    c2spd,
                    c2specialinterestindicator,
                    c2sur,
                    c3elv,
                    c3lat,
                    c3lon,
                    c3ptl,
                    c3ptnum,
                    c4colon,
                    c4def,
                    c4egress,
                    c4mod,
                    c4numberofstores,
                    c4runin,
                    c4tgt,
                    c4timediscrete,
                    c4tm,
                    c4typeofstores,
                    c5colon,
                    c5elevationlsbs,
                    c5haeadj,
                    c5latlsb,
                    c5lonlsb,
                    c5tgtbrng,
                    c5tw,
                    c6dspc,
                    c6dspct,
                    c6fplpm,
                    c6intel,
                    c6laser,
                    c6longpm,
                    c6tnr3,
                    c7elang2,
                    c7in3p,
                    c7tnor,
                    createdAt,
                    createdBy,
                    env,
                    index,
                    lat,
                    lon,
                    orginx,
                    origin,
                    origNetwork,
                    rc,
                    rr,
                    sz,
                    tno,
                    trkId,
                    twenv,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Body = apply {
            if (validated) {
                return@apply
            }

            classificationMarking()
            dataMode().validate()
            mad()
            source()
            ts()
            bodyId()
            c1associateddmpis()
            c2air()
            c2alt()
            c2crs()
            c2exerciseindicator()
            c2exercisemof()
            c2id()
            c2idamplifyingdescriptor()
            c2lnd()
            c2spc()
            c2spd()
            c2specialinterestindicator()
            c2sur()
            c3elv()
            c3lat()
            c3lon()
            c3ptl()
            c3ptnum()
            c4colon()
            c4def()
            c4egress()
            c4mod()
            c4numberofstores()
            c4runin()
            c4tgt()
            c4timediscrete()
            c4tm()
            c4typeofstores()
            c5colon()
            c5elevationlsbs()
            c5haeadj()
            c5latlsb()
            c5lonlsb()
            c5tgtbrng()
            c5tw()
            c6dspc()
            c6dspct()
            c6fplpm()
            c6intel()
            c6laser()
            c6longpm()
            c6tnr3()
            c7elang2()
            c7in3p()
            c7tnor()
            createdAt()
            createdBy()
            env()
            index()
            lat()
            lon()
            orginx()
            origin()
            origNetwork()
            rc()
            rr()
            sz()
            tno()
            trkId()
            twenv()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: UnifieddatalibraryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (classificationMarking.asKnown().isPresent) 1 else 0) +
                (dataMode.asKnown().getOrNull()?.validity() ?: 0) +
                (if (mad.asKnown().isPresent) 1 else 0) +
                (if (source.asKnown().isPresent) 1 else 0) +
                (if (ts.asKnown().isPresent) 1 else 0) +
                (if (bodyId.asKnown().isPresent) 1 else 0) +
                (if (c1associateddmpis.asKnown().isPresent) 1 else 0) +
                (if (c2air.asKnown().isPresent) 1 else 0) +
                (if (c2alt.asKnown().isPresent) 1 else 0) +
                (if (c2crs.asKnown().isPresent) 1 else 0) +
                (if (c2exerciseindicator.asKnown().isPresent) 1 else 0) +
                (if (c2exercisemof.asKnown().isPresent) 1 else 0) +
                (if (c2id.asKnown().isPresent) 1 else 0) +
                (if (c2idamplifyingdescriptor.asKnown().isPresent) 1 else 0) +
                (if (c2lnd.asKnown().isPresent) 1 else 0) +
                (if (c2spc.asKnown().isPresent) 1 else 0) +
                (if (c2spd.asKnown().isPresent) 1 else 0) +
                (if (c2specialinterestindicator.asKnown().isPresent) 1 else 0) +
                (if (c2sur.asKnown().isPresent) 1 else 0) +
                (if (c3elv.asKnown().isPresent) 1 else 0) +
                (if (c3lat.asKnown().isPresent) 1 else 0) +
                (if (c3lon.asKnown().isPresent) 1 else 0) +
                (if (c3ptl.asKnown().isPresent) 1 else 0) +
                (if (c3ptnum.asKnown().isPresent) 1 else 0) +
                (if (c4colon.asKnown().isPresent) 1 else 0) +
                (if (c4def.asKnown().isPresent) 1 else 0) +
                (if (c4egress.asKnown().isPresent) 1 else 0) +
                (if (c4mod.asKnown().isPresent) 1 else 0) +
                (if (c4numberofstores.asKnown().isPresent) 1 else 0) +
                (if (c4runin.asKnown().isPresent) 1 else 0) +
                (if (c4tgt.asKnown().isPresent) 1 else 0) +
                (if (c4timediscrete.asKnown().isPresent) 1 else 0) +
                (if (c4tm.asKnown().isPresent) 1 else 0) +
                (if (c4typeofstores.asKnown().isPresent) 1 else 0) +
                (if (c5colon.asKnown().isPresent) 1 else 0) +
                (if (c5elevationlsbs.asKnown().isPresent) 1 else 0) +
                (if (c5haeadj.asKnown().isPresent) 1 else 0) +
                (if (c5latlsb.asKnown().isPresent) 1 else 0) +
                (if (c5lonlsb.asKnown().isPresent) 1 else 0) +
                (if (c5tgtbrng.asKnown().isPresent) 1 else 0) +
                (if (c5tw.asKnown().isPresent) 1 else 0) +
                (if (c6dspc.asKnown().isPresent) 1 else 0) +
                (if (c6dspct.asKnown().isPresent) 1 else 0) +
                (if (c6fplpm.asKnown().isPresent) 1 else 0) +
                (if (c6intel.asKnown().isPresent) 1 else 0) +
                (if (c6laser.asKnown().isPresent) 1 else 0) +
                (if (c6longpm.asKnown().isPresent) 1 else 0) +
                (if (c6tnr3.asKnown().isPresent) 1 else 0) +
                (if (c7elang2.asKnown().isPresent) 1 else 0) +
                (if (c7in3p.asKnown().isPresent) 1 else 0) +
                (if (c7tnor.asKnown().isPresent) 1 else 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (if (createdBy.asKnown().isPresent) 1 else 0) +
                (if (env.asKnown().isPresent) 1 else 0) +
                (if (index.asKnown().isPresent) 1 else 0) +
                (if (lat.asKnown().isPresent) 1 else 0) +
                (if (lon.asKnown().isPresent) 1 else 0) +
                (if (orginx.asKnown().isPresent) 1 else 0) +
                (if (origin.asKnown().isPresent) 1 else 0) +
                (if (origNetwork.asKnown().isPresent) 1 else 0) +
                (if (rc.asKnown().isPresent) 1 else 0) +
                (if (rr.asKnown().isPresent) 1 else 0) +
                (if (sz.asKnown().isPresent) 1 else 0) +
                (if (tno.asKnown().isPresent) 1 else 0) +
                (if (trkId.asKnown().isPresent) 1 else 0) +
                (if (twenv.asKnown().isPresent) 1 else 0)

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Body && classificationMarking == other.classificationMarking && dataMode == other.dataMode && mad == other.mad && source == other.source && ts == other.ts && bodyId == other.bodyId && c1associateddmpis == other.c1associateddmpis && c2air == other.c2air && c2alt == other.c2alt && c2crs == other.c2crs && c2exerciseindicator == other.c2exerciseindicator && c2exercisemof == other.c2exercisemof && c2id == other.c2id && c2idamplifyingdescriptor == other.c2idamplifyingdescriptor && c2lnd == other.c2lnd && c2spc == other.c2spc && c2spd == other.c2spd && c2specialinterestindicator == other.c2specialinterestindicator && c2sur == other.c2sur && c3elv == other.c3elv && c3lat == other.c3lat && c3lon == other.c3lon && c3ptl == other.c3ptl && c3ptnum == other.c3ptnum && c4colon == other.c4colon && c4def == other.c4def && c4egress == other.c4egress && c4mod == other.c4mod && c4numberofstores == other.c4numberofstores && c4runin == other.c4runin && c4tgt == other.c4tgt && c4timediscrete == other.c4timediscrete && c4tm == other.c4tm && c4typeofstores == other.c4typeofstores && c5colon == other.c5colon && c5elevationlsbs == other.c5elevationlsbs && c5haeadj == other.c5haeadj && c5latlsb == other.c5latlsb && c5lonlsb == other.c5lonlsb && c5tgtbrng == other.c5tgtbrng && c5tw == other.c5tw && c6dspc == other.c6dspc && c6dspct == other.c6dspct && c6fplpm == other.c6fplpm && c6intel == other.c6intel && c6laser == other.c6laser && c6longpm == other.c6longpm && c6tnr3 == other.c6tnr3 && c7elang2 == other.c7elang2 && c7in3p == other.c7in3p && c7tnor == other.c7tnor && createdAt == other.createdAt && createdBy == other.createdBy && env == other.env && index == other.index && lat == other.lat && lon == other.lon && orginx == other.orginx && origin == other.origin && origNetwork == other.origNetwork && rc == other.rc && rr == other.rr && sz == other.sz && tno == other.tno && trkId == other.trkId && twenv == other.twenv && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(classificationMarking, dataMode, mad, source, ts, bodyId, c1associateddmpis, c2air, c2alt, c2crs, c2exerciseindicator, c2exercisemof, c2id, c2idamplifyingdescriptor, c2lnd, c2spc, c2spd, c2specialinterestindicator, c2sur, c3elv, c3lat, c3lon, c3ptl, c3ptnum, c4colon, c4def, c4egress, c4mod, c4numberofstores, c4runin, c4tgt, c4timediscrete, c4tm, c4typeofstores, c5colon, c5elevationlsbs, c5haeadj, c5latlsb, c5lonlsb, c5tgtbrng, c5tw, c6dspc, c6dspct, c6fplpm, c6intel, c6laser, c6longpm, c6tnr3, c7elang2, c7in3p, c7tnor, createdAt, createdBy, env, index, lat, lon, orginx, origin, origNetwork, rc, rr, sz, tno, trkId, twenv, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Body{classificationMarking=$classificationMarking, dataMode=$dataMode, mad=$mad, source=$source, ts=$ts, bodyId=$bodyId, c1associateddmpis=$c1associateddmpis, c2air=$c2air, c2alt=$c2alt, c2crs=$c2crs, c2exerciseindicator=$c2exerciseindicator, c2exercisemof=$c2exercisemof, c2id=$c2id, c2idamplifyingdescriptor=$c2idamplifyingdescriptor, c2lnd=$c2lnd, c2spc=$c2spc, c2spd=$c2spd, c2specialinterestindicator=$c2specialinterestindicator, c2sur=$c2sur, c3elv=$c3elv, c3lat=$c3lat, c3lon=$c3lon, c3ptl=$c3ptl, c3ptnum=$c3ptnum, c4colon=$c4colon, c4def=$c4def, c4egress=$c4egress, c4mod=$c4mod, c4numberofstores=$c4numberofstores, c4runin=$c4runin, c4tgt=$c4tgt, c4timediscrete=$c4timediscrete, c4tm=$c4tm, c4typeofstores=$c4typeofstores, c5colon=$c5colon, c5elevationlsbs=$c5elevationlsbs, c5haeadj=$c5haeadj, c5latlsb=$c5latlsb, c5lonlsb=$c5lonlsb, c5tgtbrng=$c5tgtbrng, c5tw=$c5tw, c6dspc=$c6dspc, c6dspct=$c6dspct, c6fplpm=$c6fplpm, c6intel=$c6intel, c6laser=$c6laser, c6longpm=$c6longpm, c6tnr3=$c6tnr3, c7elang2=$c7elang2, c7in3p=$c7in3p, c7tnor=$c7tnor, createdAt=$createdAt, createdBy=$createdBy, env=$env, index=$index, lat=$lat, lon=$lon, orginx=$orginx, origin=$origin, origNetwork=$origNetwork, rc=$rc, rr=$rr, sz=$sz, tno=$tno, trkId=$trkId, twenv=$twenv, additionalProperties=$additionalProperties}"
    }

    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
     *
     * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include
     * both real and simulated data.
     *
     * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and
     * analysis.
     *
     * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
     *
     * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and
     * requirements, and for validating technical, functional, and performance characteristics.
     */
    class DataMode @JsonCreator private constructor(private val value: JsonField<String>) : Enum {

        /**
         * Returns this class instance's raw value.
         *
         * This is usually only useful if this instance was deserialized from data that doesn't
         * match any known member, and you want to know that value. For example, if the SDK is on an
         * older version than the API, then the API may respond with new members that the SDK is
         * unaware of.
         */
        @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

        companion object {

            @JvmField val REAL = of("REAL")

            @JvmField val TEST = of("TEST")

            @JvmField val SIMULATED = of("SIMULATED")

            @JvmField val EXERCISE = of("EXERCISE")

            @JvmStatic fun of(value: String) = DataMode(JsonField.of(value))
        }

        /** An enum containing [DataMode]'s known values. */
        enum class Known {
            REAL,
            TEST,
            SIMULATED,
            EXERCISE,
        }

        /**
         * An enum containing [DataMode]'s known values, as well as an [_UNKNOWN] member.
         *
         * An instance of [DataMode] can contain an unknown value in a couple of cases:
         * - It was deserialized from data that doesn't match any known member. For example, if the
         *   SDK is on an older version than the API, then the API may respond with new members that
         *   the SDK is unaware of.
         * - It was constructed with an arbitrary value using the [of] method.
         */
        enum class Value {
            REAL,
            TEST,
            SIMULATED,
            EXERCISE,
            /** An enum member indicating that [DataMode] was instantiated with an unknown value. */
            _UNKNOWN,
        }

        /**
         * Returns an enum member corresponding to this class instance's value, or [Value._UNKNOWN]
         * if the class was instantiated with an unknown value.
         *
         * Use the [known] method instead if you're certain the value is always known or if you want
         * to throw for the unknown case.
         */
        fun value(): Value =
            when (this) {
                REAL -> Value.REAL
                TEST -> Value.TEST
                SIMULATED -> Value.SIMULATED
                EXERCISE -> Value.EXERCISE
                else -> Value._UNKNOWN
            }

        /**
         * Returns an enum member corresponding to this class instance's value.
         *
         * Use the [value] method instead if you're uncertain the value is always known and don't
         * want to throw for the unknown case.
         *
         * @throws UnifieddatalibraryInvalidDataException if this class instance's value is a not a
         *   known member.
         */
        fun known(): Known =
            when (this) {
                REAL -> Known.REAL
                TEST -> Known.TEST
                SIMULATED -> Known.SIMULATED
                EXERCISE -> Known.EXERCISE
                else -> throw UnifieddatalibraryInvalidDataException("Unknown DataMode: $value")
            }

        /**
         * Returns this class instance's primitive wire representation.
         *
         * This differs from the [toString] method because that method is primarily for debugging
         * and generally doesn't throw.
         *
         * @throws UnifieddatalibraryInvalidDataException if this class instance's value does not
         *   have the expected primitive type.
         */
        fun asString(): String =
            _value().asString().orElseThrow {
                UnifieddatalibraryInvalidDataException("Value is not a String")
            }

        private var validated: Boolean = false

        fun validate(): DataMode = apply {
            if (validated) {
                return@apply
            }

            known()
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: UnifieddatalibraryInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is DataMode && value == other.value /* spotless:on */
        }

        override fun hashCode() = value.hashCode()

        override fun toString() = value.toString()
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is MissionAssignmentUpdateParams && pathId == other.pathId && body == other.body && additionalHeaders == other.additionalHeaders && additionalQueryParams == other.additionalQueryParams /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(pathId, body, additionalHeaders, additionalQueryParams) /* spotless:on */

    override fun toString() =
        "MissionAssignmentUpdateParams{pathId=$pathId, body=$body, additionalHeaders=$additionalHeaders, additionalQueryParams=$additionalQueryParams}"
}
